<?xml version="1.0" encoding="UTF-8"?>
<project version="4">
  <component name="CopilotDiffPersistence">
    <option name="pendingDiffs">
      <map>
        <entry key="$PROJECT_DIR$/app/build.gradle">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/app/build.gradle" />
              <option name="originalContent" value="plugins {&#10;    id 'com.android.application'&#10;}&#10;&#10;android {&#10;    namespace 'ar.edu.uade.toto_app'&#10;    compileSdk 35&#10;&#10;    defaultConfig {&#10;        applicationId &quot;ar.edu.uade.toto_app&quot;&#10;        minSdk 23&#10;        targetSdk 35&#10;        versionCode 1&#10;        versionName &quot;1.0&quot;&#10;&#10;        // placeholder por si lo querés usar en notificaciones/títulos&#10;        manifestPlaceholders = [appName: &quot;Toto&quot;]&#10;    }&#10;&#10;    // Asegura que BuildConfig se genere (a veces el IDE lo “pierde”)&#10;    buildFeatures {&#10;        buildConfig true&#10;    }&#10;&#10;    buildTypes {&#10;        debug {&#10;            // ¡Debe terminar en &quot;/&quot;!&#10;//            buildConfigField &quot;String&quot;, &quot;BACKEND_BASE_URL&quot;, &quot;\&quot;http://192.168.1.9:8080/\&quot;&quot;&#10;            buildConfigField &quot;String&quot;, &quot;BACKEND_BASE_URL&quot;, &quot;\&quot;https://toto-backend-production.up.railway.app/\&quot;&quot;&#10;        }&#10;        release {&#10;            minifyEnabled false&#10;            proguardFiles getDefaultProguardFile('proguard-android-optimize.txt'), 'proguard-rules.pro'&#10;            // Cambiá por tu URL real de prod. ¡Debe terminar en &quot;/&quot;!&#10;            buildConfigField &quot;String&quot;, &quot;BACKEND_BASE_URL&quot;, &quot;\&quot;https://toto-backend-production.up.railway.app/\&quot;&quot;&#10;//            buildConfigField &quot;String&quot;, &quot;BACKEND_BASE_URL&quot;, &quot;\&quot;http://192.168.1.9:8080/\&quot;&quot;&#10;        }&#10;    }&#10;&#10;    compileOptions {&#10;        sourceCompatibility JavaVersion.VERSION_11&#10;        targetCompatibility JavaVersion.VERSION_11&#10;    }&#10;&#10;    packagingOptions {&#10;        exclude 'META-INF/**'&#10;    }&#10;}&#10;&#10;dependencies {&#10;    implementation &quot;androidx.appcompat:appcompat:1.7.0&quot;&#10;    implementation &quot;com.google.android.material:material:1.12.0&quot;&#10;    implementation &quot;androidx.activity:activity:1.9.2&quot;&#10;    implementation &quot;androidx.core:core-ktx:1.13.1&quot;&#10;&#10;    // Retrofit + OkHttp&#10;    implementation &quot;com.squareup.retrofit2:retrofit:2.11.0&quot;&#10;    implementation &quot;com.squareup.retrofit2:converter-gson:2.11.0&quot;&#10;    implementation &quot;com.squareup.okhttp3:okhttp:4.12.0&quot;&#10;    implementation &quot;com.squareup.okhttp3:logging-interceptor:4.12.0&quot;&#10;    implementation &quot;com.google.code.gson:gson:2.11.0&quot;&#10;&#10;    // Vosk Android (ASR offline)&#10;    implementation &quot;com.alphacephei:vosk-android:0.3.47&quot;&#10;&#10;    // yamnet&#10;    implementation &quot;org.tensorflow:tensorflow-lite-task-audio:0.4.4&quot;&#10;    implementation &quot;org.tensorflow:tensorflow-lite-support:0.4.4&quot;&#10;}&#10;" />
              <option name="updatedContent" value="plugins {&#10;    id 'com.android.application'&#10;}&#10;&#10;android {&#10;    namespace 'ar.edu.uade.toto_app'&#10;    compileSdk 35&#10;&#10;    defaultConfig {&#10;        applicationId &quot;ar.edu.uade.toto_app&quot;&#10;        minSdk 23&#10;        targetSdk 35&#10;        versionCode 1&#10;        versionName &quot;1.0&quot;&#10;&#10;        // placeholder por si lo querés usar en notificaciones/títulos&#10;        manifestPlaceholders = [appName: &quot;Toto&quot;]&#10;    }&#10;&#10;    // Asegura que BuildConfig se genere (a veces el IDE lo “pierde”)&#10;    buildFeatures {&#10;        buildConfig true&#10;    }&#10;&#10;    buildTypes {&#10;        debug {&#10;            // ¡Debe terminar en &quot;/&quot;!&#10;//            buildConfigField &quot;String&quot;, &quot;BACKEND_BASE_URL&quot;, &quot;\&quot;http://192.168.1.9:8080/\&quot;&quot;&#10;            buildConfigField &quot;String&quot;, &quot;BACKEND_BASE_URL&quot;, &quot;\&quot;https://toto-backend-production.up.railway.app/\&quot;&quot;&#10;        }&#10;        release {&#10;            minifyEnabled false&#10;            proguardFiles getDefaultProguardFile('proguard-android-optimize.txt'), 'proguard-rules.pro'&#10;            // Cambiá por tu URL real de prod. ¡Debe terminar en &quot;/&quot;!&#10;            buildConfigField &quot;String&quot;, &quot;BACKEND_BASE_URL&quot;, &quot;\&quot;https://toto-backend-production.up.railway.app/\&quot;&quot;&#10;//            buildConfigField &quot;String&quot;, &quot;BACKEND_BASE_URL&quot;, &quot;\&quot;http://192.168.1.9:8080/\&quot;&quot;&#10;        }&#10;    }&#10;&#10;    compileOptions {&#10;        sourceCompatibility JavaVersion.VERSION_11&#10;        targetCompatibility JavaVersion.VERSION_11&#10;    }&#10;&#10;    packagingOptions {&#10;        exclude 'META-INF/**'&#10;    }&#10;}&#10;&#10;dependencies {&#10;    implementation &quot;androidx.appcompat:appcompat:1.7.0&quot;&#10;    implementation &quot;com.google.android.material:material:1.12.0&quot;&#10;    implementation &quot;androidx.activity:activity:1.9.2&quot;&#10;    implementation &quot;androidx.core:core-ktx:1.13.1&quot;&#10;&#10;    // Retrofit + OkHttp&#10;    implementation &quot;com.squareup.retrofit2:retrofit:2.11.0&quot;&#10;    implementation &quot;com.squareup.retrofit2:converter-gson:2.11.0&quot;&#10;    implementation &quot;com.squareup.okhttp3:okhttp:4.12.0&quot;&#10;    implementation &quot;com.squareup.okhttp3:logging-interceptor:4.12.0&quot;&#10;    implementation &quot;com.google.code.gson:gson:2.11.0&quot;&#10;&#10;    // Vosk Android (ASR offline)&#10;    implementation &quot;com.alphacephei:vosk-android:0.3.47&quot;&#10;&#10;    // yamnet&#10;    implementation &quot;org.tensorflow:tensorflow-lite-task-audio:0.4.4&quot;&#10;    implementation &quot;org.tensorflow:tensorflow-lite-support:0.4.4&quot;&#10;&#10;    // WorkManager para reintentos de health check&#10;    implementation &quot;androidx.work:work-runtime:2.8.1&quot;&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/app/src/main/AndroidManifest.xml">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/app/src/main/AndroidManifest.xml" />
              <option name="originalContent" value="&lt;manifest xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;&gt;&#10;&#10;    &lt;uses-permission android:name=&quot;android.permission.INTERNET&quot; /&gt;&#10;    &lt;uses-permission android:name=&quot;android.permission.RECORD_AUDIO&quot; /&gt;&#10;    &lt;uses-permission android:name=&quot;android.permission.FOREGROUND_SERVICE&quot; /&gt;&#10;    &lt;uses-permission android:name=&quot;android.permission.FOREGROUND_SERVICE_MICROPHONE&quot; /&gt;&#10;    &lt;uses-permission android:name=&quot;android.permission.FOREGROUND_SERVICE_PHONE_CALL&quot; /&gt;&#10;    &lt;uses-permission android:name=&quot;android.permission.RECEIVE_BOOT_COMPLETED&quot; /&gt;&#10;    &lt;uses-permission android:name=&quot;android.permission.READ_CONTACTS&quot;/&gt;&#10;    &lt;uses-permission android:name=&quot;android.permission.WAKE_LOCK&quot; /&gt;&#10;    &lt;uses-permission android:name=&quot;android.permission.POST_NOTIFICATIONS&quot; /&gt;&#10;    &lt;uses-permission android:name=&quot;android.permission.CALL_PHONE&quot;/&gt;&#10;    &lt;uses-permission android:name=&quot;com.android.alarm.permission.SET_ALARM&quot; /&gt;&#10;    &lt;uses-permission android:name=&quot;android.permission.USE_FULL_SCREEN_INTENT&quot; /&gt;&#10;&#10;    &lt;queries&gt;&#10;        &lt;package android:name=&quot;com.spotify.music&quot;/&gt;&#10;    &lt;/queries&gt;&#10;&#10;    &lt;application&#10;        android:allowBackup=&quot;true&quot;&#10;        android:label=&quot;@string/app_name&quot;&#10;        android:icon=&quot;@mipmap/ic_launcher&quot;&#10;        android:supportsRtl=&quot;true&quot;&#10;        android:theme=&quot;@style/Theme.AppCompat.DayNight.NoActionBar&quot;&#10;        android:networkSecurityConfig=&quot;@xml/network_security_config&quot;&gt;&#10;&#10;        &lt;activity&#10;            android:name=&quot;com.example.toto_app.MainActivity&quot;&#10;            android:exported=&quot;true&quot;&gt;&#10;            &lt;intent-filter&gt;&#10;                &lt;action android:name=&quot;android.intent.action.MAIN&quot; /&gt;&#10;                &lt;category android:name=&quot;android.intent.category.LAUNCHER&quot; /&gt;&#10;            &lt;/intent-filter&gt;&#10;&#10;            &lt;intent-filter&gt;&#10;                &lt;action android:name=&quot;android.intent.action.VIEW&quot;/&gt;&#10;                &lt;category android:name=&quot;android.intent.category.DEFAULT&quot;/&gt;&#10;                &lt;category android:name=&quot;android.intent.category.BROWSABLE&quot;/&gt;&#10;                &lt;data android:scheme=&quot;toto&quot; android:host=&quot;spotify-auth-callback&quot;/&gt;&#10;            &lt;/intent-filter&gt;&#10;        &lt;/activity&gt;&#10;&#10;        &lt;activity&#10;            android:name=&quot;com.example.toto_app.calls.CallLauncherActivity&quot;&#10;            android:exported=&quot;false&quot;&#10;            android:showWhenLocked=&quot;true&quot;&#10;            android:turnScreenOn=&quot;true&quot;&#10;            android:excludeFromRecents=&quot;true&quot;&#10;            android:theme=&quot;@style/Theme.AppCompat.Light.NoActionBar&quot; /&gt;&#10;&#10;        &lt;service&#10;            android:name=&quot;com.example.toto_app.services.WakeWordService&quot;&#10;            android:exported=&quot;false&quot;&#10;            android:foregroundServiceType=&quot;microphone&quot; /&gt;&#10;&#10;        &lt;service&#10;            android:name=&quot;com.example.toto_app.services.WhatsAppListener&quot;&#10;            android:label=&quot;Toto WhatsApp Listener&quot;&#10;            android:permission=&quot;android.permission.BIND_NOTIFICATION_LISTENER_SERVICE&quot;&#10;            android:exported=&quot;false&quot;&gt;&#10;            &lt;intent-filter&gt;&#10;                &lt;action android:name=&quot;android.service.notification.NotificationListenerService&quot; /&gt;&#10;            &lt;/intent-filter&gt;&#10;        &lt;/service&gt;&#10;&#10;        &lt;service&#10;            android:name=&quot;com.example.toto_app.services.InstructionService&quot;&#10;            android:exported=&quot;false&quot;&#10;            android:foregroundServiceType=&quot;phoneCall&quot; /&gt;&#10;&#10;        &lt;service&#10;            android:name=&quot;com.example.toto_app.services.FallDetectionService&quot;&#10;            android:exported=&quot;false&quot;&#10;            android:foregroundServiceType=&quot;microphone&quot; /&gt;&#10;&#10;        &lt;receiver&#10;            android:name=&quot;com.example.toto_app.AutoStartReceiver&quot;&#10;            android:exported=&quot;true&quot;&#10;            android:enabled=&quot;true&quot;&gt;&#10;            &lt;intent-filter&gt;&#10;                &lt;action android:name=&quot;android.intent.action.BOOT_COMPLETED&quot; /&gt;&#10;                &lt;action android:name=&quot;android.intent.action.MY_PACKAGE_REPLACED&quot; /&gt;&#10;            &lt;/intent-filter&gt;&#10;        &lt;/receiver&gt;&#10;&#10;        &lt;receiver&#10;            android:name=&quot;com.example.toto_app.receivers.CallActionReceiver&quot;&#10;            android:exported=&quot;false&quot; /&gt;&#10;&#10;        &lt;receiver&#10;            android:name=&quot;com.example.toto_app.receivers.FallTriggerReceiver&quot;&#10;            android:exported=&quot;false&quot;&gt;&#10;            &lt;intent-filter&gt;&#10;                &lt;action android:name=&quot;com.example.toto_app.ACTION_FALL_DETECTED&quot; /&gt;&#10;            &lt;/intent-filter&gt;&#10;        &lt;/receiver&gt;&#10;&#10;    &lt;/application&gt;&#10;&lt;/manifest&gt;&#10;" />
              <option name="updatedContent" value="&lt;manifest xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;&gt;&#10;&#10;    &lt;uses-permission android:name=&quot;android.permission.INTERNET&quot; /&gt;&#10;    &lt;uses-permission android:name=&quot;android.permission.RECORD_AUDIO&quot; /&gt;&#10;    &lt;uses-permission android:name=&quot;android.permission.FOREGROUND_SERVICE&quot; /&gt;&#10;    &lt;uses-permission android:name=&quot;android.permission.FOREGROUND_SERVICE_MICROPHONE&quot; /&gt;&#10;    &lt;uses-permission android:name=&quot;android.permission.FOREGROUND_SERVICE_PHONE_CALL&quot; /&gt;&#10;    &lt;uses-permission android:name=&quot;android.permission.RECEIVE_BOOT_COMPLETED&quot; /&gt;&#10;    &lt;uses-permission android:name=&quot;android.permission.READ_CONTACTS&quot;/&gt;&#10;    &lt;uses-permission android:name=&quot;android.permission.WAKE_LOCK&quot; /&gt;&#10;    &lt;uses-permission android:name=&quot;android.permission.POST_NOTIFICATIONS&quot; /&gt;&#10;    &lt;uses-permission android:name=&quot;android.permission.CALL_PHONE&quot;/&gt;&#10;    &lt;uses-permission android:name=&quot;com.android.alarm.permission.SET_ALARM&quot; /&gt;&#10;    &lt;uses-permission android:name=&quot;android.permission.USE_FULL_SCREEN_INTENT&quot; /&gt;&#10;&#10;    &lt;queries&gt;&#10;        &lt;package android:name=&quot;com.spotify.music&quot;/&gt;&#10;    &lt;/queries&gt;&#10;&#10;    &lt;application&#10;        android:name=&quot;com.example.toto_app.AppContext&quot;&#10;        android:allowBackup=&quot;true&quot;&#10;        android:label=&quot;@string/app_name&quot;&#10;        android:icon=&quot;@mipmap/ic_launcher&quot;&#10;        android:supportsRtl=&quot;true&quot;&#10;        android:theme=&quot;@style/Theme.AppCompat.DayNight.NoActionBar&quot;&#10;        android:networkSecurityConfig=&quot;@xml/network_security_config&quot;&gt;&#10;&#10;        &lt;activity&#10;            android:name=&quot;com.example.toto_app.MainActivity&quot;&#10;            android:exported=&quot;true&quot;&gt;&#10;            &lt;intent-filter&gt;&#10;                &lt;action android:name=&quot;android.intent.action.MAIN&quot; /&gt;&#10;                &lt;category android:name=&quot;android.intent.category.LAUNCHER&quot; /&gt;&#10;            &lt;/intent-filter&gt;&#10;&#10;            &lt;intent-filter&gt;&#10;                &lt;action android:name=&quot;android.intent.action.VIEW&quot;/&gt;&#10;                &lt;category android:name=&quot;android.intent.category.DEFAULT&quot;/&gt;&#10;                &lt;category android:name=&quot;android.intent.category.BROWSABLE&quot;/&gt;&#10;                &lt;data android:scheme=&quot;toto&quot; android:host=&quot;spotify-auth-callback&quot;/&gt;&#10;            &lt;/intent-filter&gt;&#10;        &lt;/activity&gt;&#10;&#10;        &lt;activity&#10;            android:name=&quot;com.example.toto_app.calls.CallLauncherActivity&quot;&#10;            android:exported=&quot;false&quot;&#10;            android:showWhenLocked=&quot;true&quot;&#10;            android:turnScreenOn=&quot;true&quot;&#10;            android:excludeFromRecents=&quot;true&quot;&#10;            android:theme=&quot;@style/Theme.AppCompat.Light.NoActionBar&quot; /&gt;&#10;&#10;        &lt;service&#10;            android:name=&quot;com.example.toto_app.services.WakeWordService&quot;&#10;            android:exported=&quot;false&quot;&#10;            android:foregroundServiceType=&quot;microphone&quot; /&gt;&#10;&#10;        &lt;service&#10;            android:name=&quot;com.example.toto_app.services.WhatsAppListener&quot;&#10;            android:label=&quot;Toto WhatsApp Listener&quot;&#10;            android:permission=&quot;android.permission.BIND_NOTIFICATION_LISTENER_SERVICE&quot;&#10;            android:exported=&quot;false&quot;&gt;&#10;            &lt;intent-filter&gt;&#10;                &lt;action android:name=&quot;android.service.notification.NotificationListenerService&quot; /&gt;&#10;            &lt;/intent-filter&gt;&#10;        &lt;/service&gt;&#10;&#10;        &lt;service&#10;            android:name=&quot;com.example.toto_app.services.InstructionService&quot;&#10;            android:exported=&quot;false&quot;&#10;            android:foregroundServiceType=&quot;phoneCall&quot; /&gt;&#10;&#10;        &lt;service&#10;            android:name=&quot;com.example.toto_app.services.FallDetectionService&quot;&#10;            android:exported=&quot;false&quot;&#10;            android:foregroundServiceType=&quot;microphone&quot; /&gt;&#10;&#10;        &lt;receiver&#10;            android:name=&quot;com.example.toto_app.AutoStartReceiver&quot;&#10;            android:exported=&quot;true&quot;&#10;            android:enabled=&quot;true&quot;&gt;&#10;            &lt;intent-filter&gt;&#10;                &lt;action android:name=&quot;android.intent.action.BOOT_COMPLETED&quot; /&gt;&#10;                &lt;action android:name=&quot;android.intent.action.MY_PACKAGE_REPLACED&quot; /&gt;&#10;            &lt;/intent-filter&gt;&#10;        &lt;/receiver&gt;&#10;&#10;        &lt;receiver&#10;            android:name=&quot;com.example.toto_app.receivers.CallActionReceiver&quot;&#10;            android:exported=&quot;false&quot; /&gt;&#10;&#10;        &lt;receiver&#10;            android:name=&quot;com.example.toto_app.receivers.FallTriggerReceiver&quot;&#10;            android:exported=&quot;false&quot;&gt;&#10;            &lt;intent-filter&gt;&#10;                &lt;action android:name=&quot;com.example.toto_app.ACTION_FALL_DETECTED&quot; /&gt;&#10;            &lt;/intent-filter&gt;&#10;        &lt;/receiver&gt;&#10;&#10;    &lt;/application&gt;&#10;&lt;/manifest&gt;" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/app/src/main/java/com/example/toto_app/AppContext.java">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/app/src/main/java/com/example/toto_app/AppContext.java" />
              <option name="updatedContent" value="package com.example.toto_app;&#10;&#10;import android.app.Application;&#10;import android.content.Context;&#10;&#10;import com.example.toto_app.services.BackendHealthManager;&#10;&#10;public class AppContext extends Application {&#10;    private static Context ctx;&#10;    @Override public void onCreate() {&#10;        super.onCreate();&#10;        ctx = getApplicationContext();&#10;        // inicializar manager de backend&#10;        BackendHealthManager.init(ctx);&#10;    }&#10;    public static Context get() { return ctx; }&#10;}&#10;" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/app/src/main/java/com/example/toto_app/falls/FallLogic.java">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/app/src/main/java/com/example/toto_app/falls/FallLogic.java" />
              <option name="originalContent" value="package com.example.toto_app.falls;&#10;&#10;import android.util.Log;&#10;&#10;import com.example.toto_app.network.WhatsAppSendRequest;&#10;import com.example.toto_app.network.WhatsAppSendResponse;&#10;import com.example.toto_app.network.RetrofitClient;&#10;&#10;import java.text.Normalizer;&#10;import java.util.Locale;&#10;&#10;public final class FallLogic {&#10;    private FallLogic(){}&#10;&#10;    public enum FallReply { OK, HELP, UNKNOWN }&#10;&#10;    public static String normEs(String raw) {&#10;        if (raw == null) return &quot;&quot;;&#10;        String s = Normalizer.normalize(raw, Normalizer.Form.NFD)&#10;                .replaceAll(&quot;\\p{M}&quot;, &quot;&quot;)&#10;                .toLowerCase(Locale.ROOT);&#10;        s = s.replaceAll(&quot;([.,])&quot;, &quot; $1 &quot;);&#10;        s = s.replaceAll(&quot;[¿?¡!;:()\\[\\]\&quot;]&quot;, &quot; &quot;);&#10;        s = s.replaceAll(&quot;\\s+&quot;, &quot; &quot;).trim();&#10;        return &quot; &quot; + s + &quot; &quot;;&#10;    }&#10;&#10;    public static boolean saysHelp(String norm) {&#10;        return norm.contains(&quot; no estoy bien &quot;)&#10;                || norm.contains(&quot; no esta bien &quot;)&#10;                || norm.contains(&quot; estoy mal &quot;)&#10;                || norm.contains(&quot; me duele &quot;)&#10;                || norm.contains(&quot; me lastime &quot;) || norm.contains(&quot; me lastimé &quot;)&#10;                || norm.contains(&quot; no me puedo mover &quot;)&#10;                || norm.contains(&quot; no puedo levantarme &quot;) || norm.contains(&quot; no puedo pararme &quot;)&#10;                || norm.contains(&quot; ayuda &quot;) || norm.contains(&quot; ayudame &quot;) || norm.contains(&quot; ayúdame &quot;)&#10;                || norm.contains(&quot; auxilio &quot;) || norm.contains(&quot; emergencia &quot;) || norm.contains(&quot; ambulancia &quot;)&#10;                || norm.contains(&quot; doctor &quot;) || norm.contains(&quot; medico &quot;) || norm.contains(&quot; médico &quot;);&#10;    }&#10;&#10;    public static boolean mentionsFall(String norm) {&#10;        return norm.contains(&quot; me cai &quot;) || norm.contains(&quot; me caí &quot;)&#10;                || norm.contains(&quot; me caigo &quot;) || norm.contains(&quot; me estoy cayendo &quot;)&#10;                || norm.contains(&quot; caida &quot;) || norm.contains(&quot; caída &quot;)&#10;                || norm.contains(&quot; me tropece &quot;) || norm.contains(&quot; me tropecé &quot;)&#10;                || norm.contains(&quot; me pegue &quot;) || norm.contains(&quot; me pegué &quot;)&#10;                || norm.contains(&quot; me desmaye &quot;) || norm.contains(&quot; me desmayé &quot;);&#10;    }&#10;&#10;    private static boolean saysOk(String norm) {&#10;        if (norm.contains(&quot; no me puedo mover &quot;)&#10;                || norm.contains(&quot; no puedo levantarme &quot;) || norm.contains(&quot; no puedo pararme &quot;)&#10;                || norm.contains(&quot; estoy mal &quot;)&#10;                || norm.contains(&quot; me duele &quot;)&#10;                || norm.contains(&quot; me lastime &quot;) || norm.contains(&quot; me lastimé &quot;)) {&#10;            return false;&#10;        }&#10;        if (norm.matches(&quot;.*\\bno\\s+estoy\\s+bien\\b.*&quot;)) return false;&#10;        if (norm.matches(&quot;.*\\bno\\s+esta\\s+bien\\b.*&quot;)) return false;&#10;        if (norm.contains(&quot; estoy bien &quot;)&#10;                || norm.contains(&quot; esta bien &quot;)&#10;                || norm.contains(&quot; esta todo bien &quot;)&#10;                || norm.contains(&quot; todo bien &quot;)&#10;                || norm.contains(&quot; todo ok &quot;)&#10;                || norm.contains(&quot; estoy ok &quot;)&#10;                || norm.contains(&quot; tranquilo &quot;) || norm.contains(&quot; tranquila &quot;)&#10;                || norm.contains(&quot; ya estoy bien &quot;)&#10;                || norm.contains(&quot; no fue nada &quot;)&#10;                || norm.contains(&quot; no te preocupes &quot;)&#10;                || norm.contains(&quot; no hay problema &quot;)&#10;                || norm.contains(&quot; no estoy mal &quot;)&#10;                || norm.contains(&quot; no me paso nada &quot;) || norm.contains(&quot; no me pasó nada &quot;)&#10;                || norm.matches(&quot;.*\\b(si|sí)\\b.*&quot;)) {&#10;            return true;&#10;        }&#10;        return false;&#10;    }&#10;&#10;    private static boolean hasStandaloneNo(String norm) {&#10;        return norm.matches(&quot;.*\\bno\\b.*&quot;)&#10;                &amp;&amp; !norm.contains(&quot; no fue nada &quot;)&#10;                &amp;&amp; !norm.contains(&quot; no te preocupes &quot;)&#10;                &amp;&amp; !norm.contains(&quot; no hay problema &quot;)&#10;                &amp;&amp; !norm.contains(&quot; no gracias &quot;)&#10;                &amp;&amp; !saysOk(norm);&#10;    }&#10;&#10;    public static FallReply assessFallReply(String norm) {&#10;        if (saysHelp(norm)) return FallReply.HELP;&#10;        if (saysOk(norm))   return FallReply.OK;&#10;        if (mentionsFall(norm)) return FallReply.HELP;&#10;        if (hasStandaloneNo(norm)) return FallReply.HELP;&#10;        return FallReply.UNKNOWN;&#10;    }&#10;&#10;    // ===== Emergencia (idéntico comportamiento) =====&#10;    public static String buildEmergencyText(String userName) {&#10;        String u = (userName == null || userName.isBlank()) ? &quot;la persona&quot; : userName;&#10;        return &quot;⚠️ Alerta: &quot; + u + &quot; puede haberse caído o pidió ayuda. &quot;&#10;                + &quot;Este aviso fue enviado automáticamente por Toto para que puedan comunicarse&quot;;&#10;    }&#10;&#10;    public static boolean sendEmergencyMessageTo(String numberE164, String userName) {&#10;        try {&#10;            String to = numberE164.replaceAll(&quot;[^0-9+]&quot;, &quot;&quot;);&#10;            String msg = buildEmergencyText(userName);&#10;            WhatsAppSendRequest wreq = new WhatsAppSendRequest(to, msg, Boolean.FALSE);&#10;            retrofit2.Response&lt;WhatsAppSendResponse&gt; wresp = RetrofitClient.api().waSend(wreq).execute();&#10;            WhatsAppSendResponse wbody = wresp.body();&#10;            return wresp.isSuccessful()&#10;                    &amp;&amp; wbody != null&#10;                    &amp;&amp; (&quot;ok&quot;.equalsIgnoreCase(wbody.status)&#10;                    || &quot;ok_template&quot;.equalsIgnoreCase(wbody.status)&#10;                    || (wbody.id != null &amp;&amp; !wbody.id.trim().isEmpty()));&#10;        } catch (Exception ex) {&#10;            Log.e(&quot;FallLogic&quot;, &quot;Error enviando WhatsApp a emergencia&quot;, ex);&#10;            return false;&#10;        }&#10;    }&#10;}&#10;&#10;" />
              <option name="updatedContent" value="package com.example.toto_app.falls;&#10;&#10;import android.util.Log;&#10;&#10;import com.example.toto_app.network.WhatsAppSendRequest;&#10;import com.example.toto_app.network.WhatsAppSendResponse;&#10;import com.example.toto_app.network.RetrofitClient;&#10;import com.example.toto_app.services.PendingEmergencyStore;&#10;&#10;import java.text.Normalizer;&#10;import java.util.Locale;&#10;&#10;public final class FallLogic {&#10;    private FallLogic(){}&#10;&#10;    public enum FallReply { OK, HELP, UNKNOWN }&#10;&#10;    public static String normEs(String raw) {&#10;        if (raw == null) return &quot;&quot;;&#10;        String s = Normalizer.normalize(raw, Normalizer.Form.NFD)&#10;                .replaceAll(&quot;\\p{M}&quot;, &quot;&quot;)&#10;                .toLowerCase(Locale.ROOT);&#10;        s = s.replaceAll(&quot;([.,])&quot;, &quot; $1 &quot;);&#10;        s = s.replaceAll(&quot;[¿?¡!;:()\\[\\]\&quot;]&quot;, &quot; &quot;);&#10;        s = s.replaceAll(&quot;\\s+&quot;, &quot; &quot;).trim();&#10;        return &quot; &quot; + s + &quot; &quot;;&#10;    }&#10;&#10;    public static boolean saysHelp(String norm) {&#10;        return norm.contains(&quot; no estoy bien &quot;)&#10;                || norm.contains(&quot; no esta bien &quot;)&#10;                || norm.contains(&quot; estoy mal &quot;)&#10;                || norm.contains(&quot; me duele &quot;)&#10;                || norm.contains(&quot; me lastime &quot;) || norm.contains(&quot; me lastimé &quot;)&#10;                || norm.contains(&quot; no me puedo mover &quot;)&#10;                || norm.contains(&quot; no puedo levantarme &quot;) || norm.contains(&quot; no puedo pararme &quot;)&#10;                || norm.contains(&quot; ayuda &quot;) || norm.contains(&quot; ayudame &quot;) || norm.contains(&quot; ayúdame &quot;)&#10;                || norm.contains(&quot; auxilio &quot;) || norm.contains(&quot; emergencia &quot;) || norm.contains(&quot; ambulancia &quot;)&#10;                || norm.contains(&quot; doctor &quot;) || norm.contains(&quot; medico &quot;) || norm.contains(&quot; médico &quot;);&#10;    }&#10;&#10;    public static boolean mentionsFall(String norm) {&#10;        // expanded forms: handle variations like &quot;cae&quot;, &quot;cayo&quot;, &quot;resbalé&quot; and also fuzzy matches&#10;        if (norm.contains(&quot; me cai &quot;) || norm.contains(&quot; me ca\u00ed &quot;)&#10;                || norm.contains(&quot; me caigo &quot;) || norm.contains(&quot; me estoy cayendo &quot;)&#10;                || norm.contains(&quot; caida &quot;) || norm.contains(&quot; ca\u00edda &quot;)&#10;                || norm.contains(&quot; me tropece &quot;) || norm.contains(&quot; me tropec\u00e9 &quot;)&#10;                || norm.contains(&quot; me pegue &quot;) || norm.contains(&quot; me pegu\u00e9 &quot;)&#10;                || norm.contains(&quot; me desmaye &quot;) || norm.contains(&quot; me desmay\u00e9 &quot;)) return true;&#10;&#10;        // verbs and stems&#10;        if (norm.contains(&quot; cae &quot;) || norm.contains(&quot; cayo &quot;) || norm.contains(&quot; caigo &quot;)) return true;&#10;        if (norm.contains(&quot; resbale &quot;) || norm.contains(&quot; resbal\u00e9 &quot;) || norm.contains(&quot; resbal\u00f3 &quot;) || norm.contains(&quot; resbalo &quot;)) return true;&#10;&#10;        // fuzzy token-level check for common misspellings near &quot;cai&quot;/&quot;cae&quot;&#10;        String s = norm.trim();&#10;        String[] toks = s.split(&quot;\\s+&quot;);&#10;        for (String t : toks) {&#10;            String tt = t.replaceAll(&quot;[^a-zA-Z0-9]&quot;, &quot;&quot;);&#10;            if (approxEqual(tt, &quot;cai&quot;, 1) || approxEqual(tt, &quot;cayo&quot;, 1) || approxEqual(tt, &quot;cae&quot;, 1)) return true;&#10;        }&#10;        return false;&#10;    }&#10;&#10;    private static boolean approxEqual(String a, String b, int maxDist) {&#10;        if (a == null || b == null) return false;&#10;        int d = levenshtein(a, b);&#10;        return d &lt;= maxDist;&#10;    }&#10;&#10;    // simple Levenshtein&#10;    private static int levenshtein(String a, String b) {&#10;        int[] costs = new int[b.length() + 1];&#10;        for (int j = 0; j &lt; costs.length; j++) costs[j] = j;&#10;        for (int i = 1; i &lt;= a.length(); i++) {&#10;            costs[0] = i;&#10;            int nw = i - 1;&#10;            for (int j = 1; j &lt;= b.length(); j++) {&#10;                int cj = Math.min(1 + Math.min(costs[j], costs[j - 1]), a.charAt(i - 1) == b.charAt(j - 1) ? nw : nw + 1);&#10;                nw = costs[j];&#10;                costs[j] = cj;&#10;            }&#10;        }&#10;        return costs[b.length()];&#10;    }&#10;&#10;    private static boolean saysOk(String norm) {&#10;        if (norm.contains(&quot; no me puedo mover &quot;)&#10;                || norm.contains(&quot; no puedo levantarme &quot;) || norm.contains(&quot; no puedo pararme &quot;)&#10;                || norm.contains(&quot; estoy mal &quot;)&#10;                || norm.contains(&quot; me duele &quot;)&#10;                || norm.contains(&quot; me lastime &quot;) || norm.contains(&quot; me lastimé &quot;)) {&#10;            return false;&#10;        }&#10;        if (norm.matches(&quot;.*\\bno\\s+estoy\\s+bien\\b.*&quot;)) return false;&#10;        if (norm.matches(&quot;.*\\bno\\s+esta\\s+bien\\b.*&quot;)) return false;&#10;        if (norm.contains(&quot; estoy bien &quot;)&#10;                || norm.contains(&quot; esta bien &quot;)&#10;                || norm.contains(&quot; esta todo bien &quot;)&#10;                || norm.contains(&quot; todo bien &quot;)&#10;                || norm.contains(&quot; todo ok &quot;)&#10;                || norm.contains(&quot; estoy ok &quot;)&#10;                || norm.contains(&quot; tranquilo &quot;) || norm.contains(&quot; tranquila &quot;)&#10;                || norm.contains(&quot; ya estoy bien &quot;)&#10;                || norm.contains(&quot; no fue nada &quot;)&#10;                || norm.contains(&quot; no te preocupes &quot;)&#10;                || norm.contains(&quot; no hay problema &quot;)&#10;                || norm.contains(&quot; no estoy mal &quot;)&#10;                || norm.contains(&quot; no me paso nada &quot;) || norm.contains(&quot; no me pasó nada &quot;)&#10;                || norm.matches(&quot;.*\\b(si|sí)\\b.*&quot;)) {&#10;            return true;&#10;        }&#10;        return false;&#10;    }&#10;&#10;    private static boolean hasStandaloneNo(String norm) {&#10;        return norm.matches(&quot;.*\\bno\\b.*&quot;)&#10;                &amp;&amp; !norm.contains(&quot; no fue nada &quot;)&#10;                &amp;&amp; !norm.contains(&quot; no te preocupes &quot;)&#10;                &amp;&amp; !norm.contains(&quot; no hay problema &quot;)&#10;                &amp;&amp; !norm.contains(&quot; no gracias &quot;)&#10;                &amp;&amp; !saysOk(norm);&#10;    }&#10;&#10;    public static FallReply assessFallReply(String norm) {&#10;        if (saysHelp(norm)) return FallReply.HELP;&#10;        if (saysOk(norm))   return FallReply.OK;&#10;        if (mentionsFall(norm)) return FallReply.HELP;&#10;        if (hasStandaloneNo(norm)) return FallReply.HELP;&#10;        return FallReply.UNKNOWN;&#10;    }&#10;&#10;    // ===== Emergencia (idéntico comportamiento) =====&#10;    public static String buildEmergencyText(String userName) {&#10;        String u = (userName == null || userName.isBlank()) ? &quot;la persona&quot; : userName;&#10;        return &quot;⚠️ Alerta: &quot; + u + &quot; puede haberse caído o pidió ayuda. &quot;&#10;                + &quot;Este aviso fue enviado automáticamente por Toto para que puedan comunicarse&quot;;&#10;    }&#10;&#10;    public static boolean sendEmergencyMessageTo(String numberE164, String userName) {&#10;        try {&#10;            String to = numberE164.replaceAll(&quot;[^0-9+]&quot;, &quot;&quot;);&#10;            String msg = buildEmergencyText(userName);&#10;            WhatsAppSendRequest wreq = new WhatsAppSendRequest(to, msg, Boolean.FALSE);&#10;            retrofit2.Response&lt;WhatsAppSendResponse&gt; wresp = RetrofitClient.api().waSend(wreq).execute();&#10;            WhatsAppSendResponse wbody = wresp.body();&#10;            return wresp.isSuccessful()&#10;                    &amp;&amp; wbody != null&#10;                    &amp;&amp; (&quot;ok&quot;.equalsIgnoreCase(wbody.status)&#10;                    || &quot;ok_template&quot;.equalsIgnoreCase(wbody.status)&#10;                    || (wbody.id != null &amp;&amp; !wbody.id.trim().isEmpty()));&#10;        } catch (Exception ex) {&#10;            Log.e(&quot;FallLogic&quot;, &quot;Error enviando WhatsApp a emergencia&quot;, ex);&#10;            // Si falló, encolar para reintentar cuando el backend vuelva&#10;            try {&#10;                PendingEmergencyStore.get().add(numberE164, userName);&#10;            } catch (Exception e2) { Log.e(&quot;FallLogic&quot;, &quot;No se pudo encolar emergencia&quot;, e2); }&#10;            try { com.example.toto_app.services.BackendHealthManager.get().markFailure(); } catch (Exception ignore) {}&#10;            return false;&#10;        }&#10;    }&#10;&#10;    /**&#10;     * Result codes: 0=sent, 1=queued (backend down), 2=failed&#10;     */&#10;    public static int sendEmergencyMessageToResult(String numberE164, String userName) {&#10;        try {&#10;            String to = numberE164.replaceAll(&quot;[^0-9+]&quot;, &quot;&quot;);&#10;            String msg = buildEmergencyText(userName);&#10;            WhatsAppSendRequest wreq = new WhatsAppSendRequest(to, msg, Boolean.FALSE);&#10;            retrofit2.Response&lt;WhatsAppSendResponse&gt; wresp = RetrofitClient.api().waSend(wreq).execute();&#10;            WhatsAppSendResponse wbody = wresp.body();&#10;            boolean ok = wresp.isSuccessful()&#10;                    &amp;&amp; wbody != null&#10;                    &amp;&amp; (&quot;ok&quot;.equalsIgnoreCase(wbody.status)&#10;                    || &quot;ok_template&quot;.equalsIgnoreCase(wbody.status)&#10;                    || (wbody.id != null &amp;&amp; !wbody.id.trim().isEmpty()));&#10;            if (ok) return 0;&#10;            // si la respuesta no fue ok consideramos que hay algún problema de backend (queue)&#10;            PendingEmergencyStore.get().add(numberE164, userName);&#10;            try { com.example.toto_app.services.BackendHealthManager.get().markFailure(); } catch (Exception ignore) {}&#10;            return 1;&#10;        } catch (Exception ex) {&#10;            Log.e(&quot;FallLogic&quot;, &quot;Error enviando WhatsApp a emergencia&quot;, ex);&#10;            try {&#10;                PendingEmergencyStore.get().add(numberE164, userName);&#10;            } catch (Exception e2) { Log.e(&quot;FallLogic&quot;, &quot;No se pudo encolar emergencia&quot;, e2); }&#10;            try { com.example.toto_app.services.BackendHealthManager.get().markFailure(); } catch (Exception ignore) {}&#10;            return 1;&#10;        }&#10;    }&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/app/src/main/java/com/example/toto_app/network/APIService.java">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/app/src/main/java/com/example/toto_app/network/APIService.java" />
              <option name="originalContent" value="package com.example.toto_app.network;&#10;&#10;import com.google.gson.JsonObject;&#10;&#10;import java.util.Map;&#10;&#10;import okhttp3.MultipartBody;&#10;import okhttp3.RequestBody;&#10;import retrofit2.Call;&#10;import retrofit2.http.Body;&#10;import retrofit2.http.GET;&#10;import retrofit2.http.Multipart;&#10;import retrofit2.http.POST;&#10;import retrofit2.http.Part;&#10;&#10;public interface APIService {&#10;&#10;    @Multipart&#10;    @POST(&quot;api/stt&quot;)&#10;    Call&lt;TranscriptionResponse&gt; transcribe(&#10;            @Part MultipartBody.Part audio,&#10;            @Part(&quot;language&quot;) RequestBody language,&#10;            @Part(&quot;userName&quot;) RequestBody userName&#10;    );&#10;&#10;    @POST(&quot;api/ask&quot;)&#10;    Call&lt;AskResponse&gt; ask(@Body AskRequest body);&#10;&#10;    @POST(&quot;api/nlu/route&quot;)&#10;    Call&lt;NluRouteResponse&gt; nluRoute(@Body NluRouteRequest req);&#10;&#10;    @POST(&quot;api/whatsapp/send&quot;)&#10;    Call&lt;WhatsAppSendResponse&gt; waSend(@Body WhatsAppSendRequest req);&#10;&#10;    @POST(&quot;/api/spotify/pause&quot;)&#10;    retrofit2.Call&lt;SpotifyResponse&gt; spotifyPause();&#10;&#10;    @POST(&quot;/api/spotify/next&quot;)&#10;    retrofit2.Call&lt;SpotifyResponse&gt; spotifyNext();&#10;&#10;    @POST(&quot;/api/spotify/previous&quot;)&#10;    retrofit2.Call&lt;SpotifyResponse&gt; spotifyPrev();&#10;&#10;    @POST(&quot;/api/spotify/volume&quot;)&#10;    retrofit2.Call&lt;SpotifyResponse&gt; spotifyVolume(@Body SpotifyVolumeRequest body);&#10;&#10;    @POST(&quot;/api/spotify/shuffle&quot;)&#10;    retrofit2.Call&lt;SpotifyResponse&gt; spotifyShuffle(@Body SpotifyShuffleRequest body);&#10;&#10;    @POST(&quot;/api/spotify/repeat&quot;)&#10;    retrofit2.Call&lt;SpotifyResponse&gt; spotifyRepeat(@Body SpotifyRepeatRequest body);&#10;&#10;    @GET(&quot;/api/spotify/status&quot;)&#10;    Call&lt;SpotifyStatus&gt; spotifyStatus();&#10;&#10;    @POST(&quot;/api/spotify/play&quot;)&#10;    Call&lt;JsonObject&gt; spotifyPlay(@Body Map&lt;String, String&gt; body);&#10;}&#10;" />
              <option name="updatedContent" value="package com.example.toto_app.network;&#10;&#10;import com.google.gson.JsonObject;&#10;&#10;import java.util.Map;&#10;&#10;import okhttp3.MultipartBody;&#10;import okhttp3.RequestBody;&#10;import retrofit2.Call;&#10;import retrofit2.http.Body;&#10;import retrofit2.http.GET;&#10;import retrofit2.http.Multipart;&#10;import retrofit2.http.POST;&#10;import retrofit2.http.Part;&#10;&#10;public interface APIService {&#10;&#10;    @Multipart&#10;    @POST(&quot;api/stt&quot;)&#10;    Call&lt;TranscriptionResponse&gt; transcribe(&#10;            @Part MultipartBody.Part audio,&#10;            @Part(&quot;language&quot;) RequestBody language,&#10;            @Part(&quot;userName&quot;) RequestBody userName&#10;    );&#10;&#10;    @POST(&quot;api/ask&quot;)&#10;    Call&lt;AskResponse&gt; ask(@Body AskRequest body);&#10;&#10;    @POST(&quot;api/nlu/route&quot;)&#10;    Call&lt;NluRouteResponse&gt; nluRoute(@Body NluRouteRequest req);&#10;&#10;    @POST(&quot;api/whatsapp/send&quot;)&#10;    Call&lt;WhatsAppSendResponse&gt; waSend(@Body WhatsAppSendRequest req);&#10;&#10;    @POST(&quot;/api/spotify/pause&quot;)&#10;    retrofit2.Call&lt;SpotifyResponse&gt; spotifyPause();&#10;&#10;    @POST(&quot;/api/spotify/next&quot;)&#10;    retrofit2.Call&lt;SpotifyResponse&gt; spotifyNext();&#10;&#10;    @POST(&quot;/api/spotify/previous&quot;)&#10;    retrofit2.Call&lt;SpotifyResponse&gt; spotifyPrev();&#10;&#10;    @POST(&quot;/api/spotify/volume&quot;)&#10;    retrofit2.Call&lt;SpotifyResponse&gt; spotifyVolume(@Body SpotifyVolumeRequest body);&#10;&#10;    @POST(&quot;/api/spotify/shuffle&quot;)&#10;    retrofit2.Call&lt;SpotifyResponse&gt; spotifyShuffle(@Body SpotifyShuffleRequest body);&#10;&#10;    @POST(&quot;/api/spotify/repeat&quot;)&#10;    retrofit2.Call&lt;SpotifyResponse&gt; spotifyRepeat(@Body SpotifyRepeatRequest body);&#10;&#10;    @GET(&quot;/api/spotify/status&quot;)&#10;    Call&lt;SpotifyStatus&gt; spotifyStatus();&#10;&#10;    @GET(&quot;/health&quot;)&#10;    Call&lt;com.google.gson.JsonObject&gt; health();&#10;&#10;    @POST(&quot;/api/spotify/play&quot;)&#10;    Call&lt;JsonObject&gt; spotifyPlay(@Body Map&lt;String, String&gt; body);&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/app/src/main/java/com/example/toto_app/services/BackendHealthManager.java">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/app/src/main/java/com/example/toto_app/services/BackendHealthManager.java" />
              <option name="originalContent" value="&#10;" />
              <option name="updatedContent" value="package com.example.toto_app.services;&#10;&#10;import android.content.Context;&#10;import android.os.SystemClock;&#10;import android.util.Log;&#10;&#10;import com.google.gson.JsonObject;&#10;&#10;import java.io.IOException;&#10;import java.util.concurrent.Executors;&#10;import java.util.concurrent.ScheduledExecutorService;&#10;import java.util.concurrent.TimeUnit;&#10;import androidx.work.WorkManager;&#10;import androidx.work.OneTimeWorkRequest;&#10;import androidx.work.BackoffPolicy;&#10;&#10;import ar.edu.uade.toto_app.BuildConfig;&#10;import okhttp3.Call;&#10;import okhttp3.OkHttpClient;&#10;import okhttp3.Request;&#10;import okhttp3.Response;&#10;&#10;/**&#10; * Simple manager para chequear disponibilidad del backend y notificar cuando vuelva.&#10; */&#10;public final class BackendHealthManager {&#10;    private static final String TAG = &quot;BackendHealthManager&quot;;&#10;    private static volatile BackendHealthManager INSTANCE;&#10;&#10;    private final Context ctx;&#10;    private final OkHttpClient client;&#10;    private volatile boolean backendUp = true; // asumimos UP por defecto al inicio&#10;    private volatile long lastChecked = 0L;&#10;    private static final long CACHE_MS = 5000L; // cache de 5s&#10;&#10;    private final ScheduledExecutorService scheduler = Executors.newSingleThreadScheduledExecutor();&#10;&#10;    private BackendHealthManager(Context ctx) {&#10;        this.ctx = ctx.getApplicationContext();&#10;        this.client = new OkHttpClient.Builder()&#10;                .callTimeout(2, TimeUnit.SECONDS)&#10;                .connectTimeout(2, TimeUnit.SECONDS)&#10;                .readTimeout(2, TimeUnit.SECONDS)&#10;                .build();&#10;    }&#10;&#10;    public static synchronized void init(Context ctx) {&#10;        if (INSTANCE == null) {&#10;            INSTANCE = new BackendHealthManager(ctx);&#10;        }&#10;    }&#10;&#10;    public static BackendHealthManager get() {&#10;        if (INSTANCE == null) throw new IllegalStateException(&quot;BackendHealthManager not initialized&quot;);&#10;        return INSTANCE;&#10;    }&#10;&#10;    /**&#10;     * Comprueba el estado del backend usando cache de corto plazo. Esta llamada es síncrona&#10;     * y rápida (usa un timeout corto). Si el estado es DOWN, se arranca un watcher que&#10;     * pollea periódicamente hasta que el backend vuelve.&#10;     */&#10;    public synchronized boolean isBackendUp() {&#10;        long now = SystemClock.elapsedRealtime();&#10;        if ((now - lastChecked) &lt; CACHE_MS) return backendUp;&#10;&#10;        boolean up = performHealthCheck();&#10;        setBackendUp(up);&#10;        return up;&#10;    }&#10;&#10;    // Hago pública una versión estática para que WorkManager pueda llamarla indirectamente&#10;    static boolean performCheckStatic(Context ctx) {&#10;        try {&#10;            OkHttpClient client = new OkHttpClient.Builder()&#10;                    .callTimeout(2, TimeUnit.SECONDS)&#10;                    .connectTimeout(2, TimeUnit.SECONDS)&#10;                    .readTimeout(2, TimeUnit.SECONDS)&#10;                    .build();&#10;            String url = BuildConfig.BACKEND_BASE_URL + &quot;health&quot;;&#10;            Request req = new Request.Builder().url(url).get().build();&#10;            Call c = client.newCall(req);&#10;            try (Response r = c.execute()) {&#10;                return r != null &amp;&amp; r.isSuccessful();&#10;            }&#10;        } catch (IOException e) {&#10;            Log.w(TAG, &quot;health check failed: &quot; + e.getMessage());&#10;            return false;&#10;        }&#10;    }&#10;&#10;    private boolean performHealthCheck() {&#10;        return performCheckStatic(this.ctx);&#10;    }&#10;&#10;    private synchronized void setBackendUp(boolean up) {&#10;        boolean prev = this.backendUp;&#10;        this.backendUp = up;&#10;        this.lastChecked = SystemClock.elapsedRealtime();&#10;        if (!prev &amp;&amp; up) {&#10;            Log.i(TAG, &quot;Backend recovered -&gt; flushing pending emergencies&quot;);&#10;            // enviar pendientes&#10;            scheduler.execute(() -&gt; {&#10;                try { PendingEmergencyStore.get().flushPendingNow(); } catch (Exception e) { Log.e(TAG, &quot;flush error&quot;, e); }&#10;            });&#10;        } else if (prev &amp;&amp; !up) {&#10;            Log.w(TAG, &quot;Backend marked DOWN -&gt; scheduling recovery worker&quot;);&#10;            // schedule a WorkManager retry with exponential backoff&#10;            try {&#10;                HealthCheckWorker.scheduleRetry(this.ctx, 3);&#10;            } catch (Exception e) { Log.e(TAG, &quot;error scheduling health worker&quot;, e); }&#10;        }&#10;    }&#10;&#10;    /**&#10;     * Marca fallo inmediato (p. ej. tras excepción en llamada). Esto actualiza el estado&#10;     * y arranca el watcher si aún no está en DOWN.&#10;     */&#10;    public void markFailure() {&#10;        setBackendUp(false);&#10;    }&#10; }" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/app/src/main/java/com/example/toto_app/services/HealthCheckWorker.java">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/app/src/main/java/com/example/toto_app/services/HealthCheckWorker.java" />
              <option name="updatedContent" value="package com.example.toto_app.services;&#10;&#10;import android.content.Context;&#10;import android.util.Log;&#10;&#10;import androidx.annotation.NonNull;&#10;import androidx.work.BackoffPolicy;&#10;import androidx.work.Data;&#10;import androidx.work.OneTimeWorkRequest;&#10;import androidx.work.WorkManager;&#10;import androidx.work.Worker;&#10;import androidx.work.WorkerParameters;&#10;&#10;import java.util.concurrent.TimeUnit;&#10;&#10;public class HealthCheckWorker extends Worker {&#10;    private static final String TAG = &quot;HealthCheckWorker&quot;;&#10;&#10;    public HealthCheckWorker(@NonNull Context context, @NonNull WorkerParameters params) {&#10;        super(context, params);&#10;    }&#10;&#10;    @NonNull&#10;    @Override&#10;    public Result doWork() {&#10;        try {&#10;            boolean ok = com.example.toto_app.services.BackendHealthManager.performCheckStatic(getApplicationContext());&#10;            if (ok) {&#10;                Log.i(TAG, &quot;health check ok&quot;);&#10;                return Result.success();&#10;            }&#10;        } catch (Throwable t) {&#10;            Log.w(TAG, &quot;health check worker exception&quot;, t);&#10;        }&#10;        // reintentar con backoff&#10;        return Result.retry();&#10;    }&#10;&#10;    public static void scheduleRetry(Context ctx, long delaySeconds) {&#10;        OneTimeWorkRequest req = new OneTimeWorkRequest.Builder(HealthCheckWorker.class)&#10;                .setInitialDelay(Math.max(1, delaySeconds), TimeUnit.SECONDS)&#10;                .setBackoffCriteria(BackoffPolicy.EXPONENTIAL, 10, TimeUnit.SECONDS)&#10;                .build();&#10;        WorkManager.getInstance(ctx).enqueue(req);&#10;    }&#10;}&#10;" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/app/src/main/java/com/example/toto_app/services/InstructionService.java">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/app/src/main/java/com/example/toto_app/services/InstructionService.java" />
              <option name="originalContent" value="package com.example.toto_app.services;&#10;&#10;import android.content.Intent;&#10;import android.os.IBinder;&#10;import android.os.SystemClock;&#10;import android.util.Log;&#10;&#10;import androidx.annotation.Nullable;&#10;&#10;import com.example.toto_app.actions.DeviceActions;&#10;import com.example.toto_app.audio.InstructionCapture;&#10;import com.example.toto_app.audio.VadUtils;&#10;import com.example.toto_app.calls.AppState;&#10;import com.example.toto_app.calls.PhoneCallExecutor;&#10;import com.example.toto_app.falls.FallLogic;&#10;import com.example.toto_app.falls.FallSignals;&#10;import com.example.toto_app.network.AskRequest;&#10;import com.example.toto_app.network.AskResponse;&#10;import com.example.toto_app.network.NluRouteResponse;&#10;import com.example.toto_app.network.RetrofitClient;&#10;import com.example.toto_app.network.SpotifyRepeatRequest;&#10;import com.example.toto_app.network.SpotifyResponse;&#10;import com.example.toto_app.network.SpotifyShuffleRequest;&#10;import com.example.toto_app.network.SpotifyStatus;&#10;import com.example.toto_app.network.SpotifyVolumeRequest;&#10;import com.example.toto_app.nlp.NluResolver;&#10;import com.example.toto_app.stt.SttClient;&#10;import com.example.toto_app.util.TtsSanitizer;&#10;&#10;import java.io.File;&#10;import java.text.ParseException;&#10;import java.text.SimpleDateFormat;&#10;import java.util.Calendar;&#10;import java.util.Date;&#10;import java.util.Locale;&#10;import java.util.TimeZone;&#10;import java.util.concurrent.Executors;&#10;&#10;import retrofit2.Response;&#10;&#10;public class InstructionService extends android.app.Service {&#10;&#10;    private static final String TAG = &quot;InstructionService&quot;;&#10;&#10;    private String userName = &quot;Juan&quot;;&#10;&#10;    private static final String EXTRA_FALL_MODE = &quot;fall_mode&quot;;&#10;    @Nullable private String fallMode = null;&#10;    private int fallRetry = 0;&#10;&#10;    private static final String EMERGENCY_NAME   = &quot;Tamara&quot;;&#10;    private static final String EMERGENCY_NUMBER = &quot;+5491159753115&quot;;&#10;    private boolean fallOwner = false;&#10;&#10;    @Override public void onCreate() { super.onCreate(); }&#10;&#10;    @Override&#10;    public int onStartCommand(Intent intent, int flags, int startId) {&#10;        if (intent != null) {&#10;            if (intent.hasExtra(&quot;user_name&quot;)) {&#10;                String incoming = intent.getStringExtra(&quot;user_name&quot;);&#10;                if (incoming != null &amp;&amp; !incoming.trim().isEmpty()) userName = incoming.trim();&#10;            }&#10;            if (intent.hasExtra(EXTRA_FALL_MODE)) {&#10;                String fmRaw = intent.getStringExtra(EXTRA_FALL_MODE);&#10;                if (fmRaw != null &amp;&amp; !fmRaw.trim().isEmpty()) {&#10;                    String upper = fmRaw.trim().toUpperCase(Locale.ROOT);&#10;                    String[] parts = upper.split(&quot;:&quot;, 2);&#10;                    fallMode = parts[0];&#10;                    if (parts.length &gt; 1) {&#10;                        try { fallRetry = Integer.parseInt(parts[1]); } catch (Exception ignore) {}&#10;                    }&#10;                }&#10;            }&#10;        }&#10;&#10;        if (fallMode != null) {&#10;            if (!FallSignals.isActive()) {&#10;                FallSignals.tryActivate();&#10;            }&#10;            fallOwner = true;&#10;        } else {&#10;            if (FallSignals.isActive()) {&#10;                stopSelf();&#10;                return START_NOT_STICKY;&#10;            }&#10;        }&#10;&#10;        Executors.newSingleThreadExecutor().execute(this::doWork);&#10;        return START_NOT_STICKY;&#10;    }&#10;&#10;    private void doWork() {&#10;        if (fallMode == null &amp;&amp; FallSignals.isActive()) {&#10;            stopSelf();&#10;            return;&#10;        }&#10;&#10;        if (&quot;CHECK&quot;.equals(fallMode)) {&#10;            String prompt = &quot;Escuché un golpe. ¿Estás bien?&quot;;&#10;            sayThenListenHere(prompt, &quot;AWAIT:0&quot;);&#10;            stopSelf();&#10;            return;&#10;        }&#10;&#10;        File cacheDir = getExternalCacheDir() != null ? getExternalCacheDir() : getCacheDir();&#10;        File wav = new File(cacheDir, &quot;toto_instruction_&quot; + SystemClock.elapsedRealtime() + &quot;.wav&quot;);&#10;&#10;        InstructionCapture.Config cfg = new InstructionCapture.Config();&#10;        cfg.sampleRate = 16000;&#10;        cfg.maxDurationMs = 15000;&#10;        cfg.trailingSilenceMs = 1800;&#10;        cfg.silenceDbfs = -45.0;&#10;        cfg.frameMs = 30;&#10;&#10;        if (&quot;AWAIT&quot;.equals(fallMode) || &quot;AWAIT_ACTION&quot;.equals(fallMode)) {&#10;            cfg.maxDurationMs     = 12000;&#10;            cfg.trailingSilenceMs = 3500;&#10;            cfg.silenceDbfs       = -50.0;&#10;        }&#10;&#10;        Log.d(TAG, &quot;Grabando a WAV: &quot; + wav.getAbsolutePath());&#10;        InstructionCapture.captureToWav(wav, cfg, new InstructionCapture.Listener(){});&#10;&#10;        int minVoicedMs =&#10;                (&quot;AWAIT&quot;.equals(fallMode) || &quot;AWAIT_ACTION&quot;.equals(fallMode) || &quot;CHECK&quot;.equals(fallMode))&#10;                        ? 220 : 320;&#10;&#10;        if (!VadUtils.hasEnoughVoice(wav, cfg.silenceDbfs, minVoicedMs)) {&#10;            Log.d(TAG, &quot;VAD: silencio o voz insuficiente&quot;);&#10;            if (&quot;AWAIT&quot;.equals(fallMode)) {&#10;                if (fallRetry &lt;= 0) {&#10;                    sayThenListenHere(&quot;No te escuché. ¿Estás bien?&quot;, &quot;AWAIT:1&quot;);&#10;                } else {&#10;                    boolean ok = FallLogic.sendEmergencyMessageTo(EMERGENCY_NUMBER, userName);&#10;                    if (ok) sayViaWakeService(&quot;No te escuché. Ya avisé a &quot; + EMERGENCY_NAME + &quot;.&quot;, 0);&#10;                    else    sayViaWakeService(&quot;No te escuché y no pude avisar a &quot; + EMERGENCY_NAME + &quot;.&quot;, 0);&#10;                    if (fallOwner) {&#10;                        FallSignals.clear();&#10;                        Intent resume = new Intent(this, WakeWordService.class)&#10;                                .setAction(WakeWordService.ACTION_RESUME_LISTEN)&#10;                                .putExtra(WakeWordService.EXTRA_REASON, WakeWordService.REASON_FALL_CLEAR);&#10;                        androidx.core.content.ContextCompat.startForegroundService(this, resume);&#10;                    }&#10;                }&#10;                try { wav.delete(); } catch (Exception ignore) {}&#10;                stopSelf();&#10;                return;&#10;            } else {&#10;                sayViaWakeService(&quot;No te escuché bien.&quot;, 0);&#10;                try { wav.delete(); } catch (Exception ignore) {}&#10;                stopSelf();&#10;                return;&#10;            }&#10;        }&#10;&#10;        String transcript = &quot;&quot;;&#10;        try {&#10;            transcript = SttClient.transcribe(wav);&#10;        } finally {&#10;            try { wav.delete(); } catch (Exception ignored) {}&#10;        }&#10;&#10;        if (&quot;AWAIT&quot;.equals(fallMode)) {&#10;            String norm = FallLogic.normEs(transcript);&#10;            if (norm.isEmpty()) {&#10;                if (fallRetry &lt;= 0) {&#10;                    sayThenListenHere(&quot;No te escuché. ¿Estás bien?&quot;, &quot;AWAIT:1&quot;);&#10;                } else {&#10;                    boolean ok = FallLogic.sendEmergencyMessageTo(EMERGENCY_NUMBER, userName);&#10;                    if (ok) sayViaWakeService(&quot;No te escuché. Ya avisé a &quot; + EMERGENCY_NAME + &quot;.&quot;, 0);&#10;                    else    sayViaWakeService(&quot;No te escuché y no pude avisar a &quot; + EMERGENCY_NAME + &quot;.&quot;, 0);&#10;                    if (fallOwner) {&#10;                        FallSignals.clear();&#10;                        Intent resume = new Intent(this, WakeWordService.class)&#10;                                .setAction(WakeWordService.ACTION_RESUME_LISTEN)&#10;                                .putExtra(WakeWordService.EXTRA_REASON, WakeWordService.REASON_FALL_CLEAR);&#10;                        androidx.core.content.ContextCompat.startForegroundService(this, resume);&#10;                    }&#10;                }&#10;                stopSelf();&#10;                return;&#10;            }&#10;&#10;            FallLogic.FallReply fr = FallLogic.assessFallReply(norm);&#10;            switch (fr) {&#10;                case HELP: {&#10;                    boolean ok = FallLogic.sendEmergencyMessageTo(EMERGENCY_NUMBER, userName);&#10;                    if (ok) sayViaWakeService(&quot;Ya avisé a &quot; + EMERGENCY_NAME + &quot;.&quot;, 0);&#10;                    else    sayViaWakeService(&quot;Quise avisar a &quot; + EMERGENCY_NAME + &quot; pero no pude enviar el mensaje.&quot;, 0);&#10;                    if (fallOwner) {&#10;                        FallSignals.clear();&#10;                        Intent resume = new Intent(this, WakeWordService.class)&#10;                                .setAction(WakeWordService.ACTION_RESUME_LISTEN)&#10;                                .putExtra(WakeWordService.EXTRA_REASON, WakeWordService.REASON_FALL_CLEAR);&#10;                        androidx.core.content.ContextCompat.startForegroundService(this, resume);&#10;                    }&#10;                    stopSelf(); return;&#10;                }&#10;                case OK: {&#10;                    sayViaWakeService(&quot;Me alegro. Si necesitás ayuda, decime.&quot;, 0);&#10;                    if (fallOwner) {&#10;                        FallSignals.clear();&#10;                        Intent resume = new Intent(this, WakeWordService.class)&#10;                                .setAction(WakeWordService.ACTION_RESUME_LISTEN)&#10;                                .putExtra(WakeWordService.EXTRA_REASON, WakeWordService.REASON_FALL_CLEAR);&#10;                        androidx.core.content.ContextCompat.startForegroundService(this, resume);&#10;                    }&#10;                    stopSelf(); return;&#10;                }&#10;                case UNKNOWN:&#10;                default: {&#10;                    sayThenListenHere(&quot;No me quedó claro. ¿Estás bien?&quot;, &quot;AWAIT:&quot; + fallRetry);&#10;                    stopSelf(); return;&#10;                }&#10;            }&#10;        }&#10;&#10;        if (transcript.isEmpty()) {&#10;            sayViaWakeService(&quot;No te escuché bien.&quot;, 0);&#10;            stopSelf();&#10;            return;&#10;        }&#10;&#10;        String normAll = FallLogic.normEs(transcript);&#10;        if (FallLogic.saysHelp(normAll) || FallLogic.mentionsFall(normAll)) {&#10;            sayThenListenHere(&quot;¿Estás bien?&quot;, &quot;AWAIT:0&quot;);&#10;            stopSelf();&#10;            return;&#10;        }&#10;&#10;        try {&#10;            String norm = java.text.Normalizer.normalize(transcript, java.text.Normalizer.Form.NFD)&#10;                    .replaceAll(&quot;\\p{M}&quot;, &quot;&quot;)&#10;                    .toLowerCase(java.util.Locale.ROOT)&#10;                    .replaceAll(&quot;[¿?¡!.,;:()\\[\\]\&quot;]&quot;, &quot; &quot;)&#10;                    .replaceAll(&quot;\\s+&quot;, &quot; &quot;)&#10;                    .trim();&#10;&#10;            boolean saysAffirm =&#10;                    norm.matches(&quot;^(si|dale|claro|ok|de una|bueno|obvio|por favor|si por favor|si dale)(\\s.*)?$&quot;);&#10;&#10;            boolean saysRead =&#10;                    norm.contains(&quot;leelo&quot;) || norm.contains(&quot;leela&quot;) ||&#10;                            norm.contains(&quot;leerlo&quot;) || norm.contains(&quot;leeme&quot;) ||&#10;                            norm.contains(&quot;leermelo&quot;) || norm.contains(&quot;leermela&quot;) ||&#10;                            norm.contains(&quot;lee el mensaje&quot;) || norm.contains(&quot;leelo por favor&quot;) ||&#10;                            norm.contains(&quot;leela por favor&quot;);&#10;&#10;            final long FRESH_MS = 3 * 60_000L;&#10;            boolean fresh = IncomingMessageStore.get().hasFresh(FRESH_MS);&#10;&#10;            if (fresh &amp;&amp; ((IncomingMessageStore.get().isAwaitingConfirm() &amp;&amp; saysAffirm) || saysRead)) {&#10;                IncomingMessageStore.Msg m = IncomingMessageStore.get().consume();&#10;                if (m != null) {&#10;                    String tts = (m.from == null ? &quot;alguien&quot; : m.from) + &quot; dice: &quot; + (m.body == null ? &quot;…&quot; : m.body);&#10;                    sayViaWakeService(tts, 0);&#10;                    stopSelf();&#10;                    return;&#10;                }&#10;            }&#10;        } catch (Throwable ignored) {}&#10;&#10;        NluRouteResponse nres = NluResolver.resolveWithFallback(transcript);&#10;        String intentName = (nres != null &amp;&amp; nres.intent != null)&#10;                ? nres.intent.trim().toUpperCase(java.util.Locale.ROOT) : &quot;UNKNOWN&quot;;&#10;&#10;        if (nres != null) {&#10;            Log.d(TAG, &quot;NLU/route → intent=&quot; + safe(nres.intent)&#10;                    + &quot; conf=&quot; + nres.confidence&#10;                    + &quot; needsConf=&quot; + nres.needs_confirmation&#10;                    + &quot; slots=&quot; + slotsToString(nres.slots)&#10;                    + &quot; ack=&quot; + safe(nres.ack_tts));&#10;        } else {&#10;            Log.d(TAG, &quot;NLU/route → nres=null&quot;);&#10;        }&#10;&#10;        if (nres != null &amp;&amp; nres.ack_tts != null &amp;&amp; !nres.ack_tts.trim().isEmpty()) {&#10;            boolean isAnswerish = &quot;ANSWER&quot;.equals(intentName) || &quot;UNKNOWN&quot;.equals(intentName);&#10;            boolean isSpotifyPlay = &quot;SPOTIFY_PLAY&quot;.equals(intentName);&#10;            boolean isFall = &quot;FALL&quot;.equals(intentName);&#10;            if (!&quot;QUERY_TIME&quot;.equals(intentName) &amp;&amp; !&quot;QUERY_DATE&quot;.equals(intentName)&#10;                    &amp;&amp; !isAnswerish &amp;&amp; !&quot;CALL&quot;.equals(intentName)&#10;                    &amp;&amp; !&quot;SEND_MESSAGE&quot;.equals(intentName)&#10;                    &amp;&amp; !isSpotifyPlay&#10;                    &amp;&amp; !isFall) {&#10;                if (!FallSignals.isActive()) {&#10;                    sayViaWakeService(TtsSanitizer.sanitizeForTTS(nres.ack_tts), 0);&#10;                } else {&#10;                    stopSelf(); return;&#10;                }&#10;            }&#10;        }&#10;&#10;        if (nres != null &amp;&amp; nres.needs_confirmation&#10;                &amp;&amp; nres.clarifying_question != null&#10;                &amp;&amp; !nres.clarifying_question.trim().isEmpty()) {&#10;&#10;            boolean actionable =&#10;                    &quot;SET_ALARM&quot;.equals(intentName) ||&#10;                            &quot;CALL&quot;.equals(intentName) ||&#10;                            &quot;SEND_MESSAGE&quot;.equals(intentName) ||&#10;                            &quot;SPOTIFY_PLAY&quot;.equals(intentName);&#10;&#10;            if (actionable) {&#10;                if (!FallSignals.isActive()) {&#10;                    sayViaWakeService(TtsSanitizer.sanitizeForTTS(nres.clarifying_question.trim()), 0);&#10;                }&#10;                stopSelf();&#10;                return;&#10;            }&#10;        }&#10;&#10;        switch (intentName) {&#10;            case &quot;FALL&quot;: {&#10;                if (!FallSignals.isActive()) {&#10;                    FallSignals.tryActivate();&#10;                    fallOwner = true;&#10;                }&#10;                sayThenListenHere(&quot;¿Estás bien?&quot;, &quot;AWAIT:0&quot;);&#10;                stopSelf(); return;&#10;            }&#10;&#10;            case &quot;QUERY_TIME&quot;: {&#10;                if (FallSignals.isActive()) { stopSelf(); return; }&#10;                Calendar c = Calendar.getInstance();&#10;                sayViaWakeService(&quot;Son las &quot; + DeviceActions.hhmm(&#10;                        c.get(Calendar.HOUR_OF_DAY), c.get(Calendar.MINUTE)) + &quot;.&quot;, 0);&#10;                stopSelf(); return;&#10;            }&#10;            case &quot;QUERY_DATE&quot;: {&#10;                if (FallSignals.isActive()) { stopSelf(); return; }&#10;                Locale esAR = new Locale(&quot;es&quot;, &quot;AR&quot;);&#10;                Calendar c = Calendar.getInstance();&#10;                SimpleDateFormat fmt = new SimpleDateFormat(&quot;EEEE, d 'de' MMMM 'de' yyyy&quot;, esAR);&#10;                String pretty = capitalizeFirst(fmt.format(c.getTime()), esAR);&#10;                sayViaWakeService(&quot;Hoy es &quot; + pretty + &quot;.&quot;, 0);&#10;                stopSelf(); return;&#10;            }&#10;            case &quot;SET_ALARM&quot;: {&#10;                if (FallSignals.isActive()) { stopSelf(); return; }&#10;                Integer hh = (nres != null &amp;&amp; nres.slots != null) ? nres.slots.hour : null;&#10;                Integer mm = (nres != null &amp;&amp; nres.slots != null) ? nres.slots.minute : null;&#10;&#10;                if ((hh == null || mm == null) &amp;&amp; nres != null &amp;&amp; nres.slots != null&#10;                        &amp;&amp; nres.slots.datetime_iso != null &amp;&amp; !nres.slots.datetime_iso.isEmpty()) {&#10;                    int[] hm = tryParseIsoToLocalHourMinute(nres.slots.datetime_iso);&#10;                    if (hm != null) { hh = hm[0]; mm = hm[1]; }&#10;                }&#10;                if (hh == null || mm == null) {&#10;                    sayViaWakeService(&quot;¿Para qué hora querés la alarma?&quot;, 0);&#10;                    stopSelf(); return;&#10;                }&#10;                DeviceActions.AlarmResult res = DeviceActions.setAlarm(this, hh, mm, &quot;Toto&quot;);&#10;                handleAlarmResult(res, DeviceActions.hhmm(hh, mm));&#10;                stopSelf(); return;&#10;            }&#10;&#10;            case &quot;CALL&quot;: {&#10;                if (FallSignals.isActive()) { stopSelf(); return; }&#10;                String who = (nres != null &amp;&amp; nres.slots != null) ? nres.slots.contact_query : null;&#10;                if (who == null || who.trim().isEmpty()) {&#10;                    sayViaWakeService(&quot;¿A quién querés que llame?&quot;, 0);&#10;                    stopSelf(); return;&#10;                }&#10;&#10;                boolean hasContacts = androidx.core.content.ContextCompat.checkSelfPermission(&#10;                        this, android.Manifest.permission.READ_CONTACTS)&#10;                        == android.content.pm.PackageManager.PERMISSION_GRANTED;&#10;&#10;                if (!hasContacts) {&#10;                    sayViaWakeService(&quot;Necesito permiso de contactos para llamar por nombre. Abrí la app para darlo.&quot;, 0);&#10;                    Intent perm = new Intent(this, com.example.toto_app.MainActivity.class)&#10;                            .addFlags(Intent.FLAG_ACTIVITY_NEW_TASK)&#10;                            .putExtra(&quot;request_contacts_perm&quot;, true);&#10;                    startActivity(perm);&#10;                    postWatchdog(8000);&#10;                    stopSelf(); return;&#10;                }&#10;&#10;                DeviceActions.ResolvedContact rc = DeviceActions.resolveContactByNameFuzzy(this, who);&#10;                if ((rc == null || rc.number == null || rc.number.isEmpty())&#10;                        &amp;&amp; who.startsWith(&quot;a&quot;) &amp;&amp; who.length() &gt;= 3) {&#10;                    rc = DeviceActions.resolveContactByNameFuzzy(this, who.substring(1));&#10;                }&#10;                if ((rc == null || rc.number == null || rc.number.isEmpty()) &amp;&amp; looksLikePhoneNumber(who)) {&#10;                    String dial = normalizeDialable(who);&#10;                    rc = new DeviceActions.ResolvedContact(who, dial, 1.0);&#10;                }&#10;&#10;                if (rc == null || rc.number == null || rc.number.isEmpty()) {&#10;                    NotificationService.showCallNotification(this, who, null,&#10;                            androidx.core.content.ContextCompat.checkSelfPermission(&#10;                                    this, android.Manifest.permission.CALL_PHONE)&#10;                                    == android.content.pm.PackageManager.PERMISSION_GRANTED);&#10;                    sayViaWakeService(&quot;No encontré a &quot; + who + &quot; en tus contactos. Te dejé una notificación para marcar.&quot;, 0);&#10;                    postWatchdog(8000);&#10;                    stopSelf(); return;&#10;                }&#10;&#10;                if (!AppState.isAppInForeground(this)) {&#10;                    NotificationService.showCallNotification(this, rc.name, rc.number,&#10;                            androidx.core.content.ContextCompat.checkSelfPermission(&#10;                                    this, android.Manifest.permission.CALL_PHONE)&#10;                                    == android.content.pm.PackageManager.PERMISSION_GRANTED);&#10;                    sayViaWakeService(&quot;Tocá la notificación para llamar a &quot; + rc.name + &quot;.&quot;, 0);&#10;                    postWatchdog(8000);&#10;                    stopSelf(); return;&#10;                }&#10;                if (AppState.isDeviceLocked(this)) {&#10;                    NotificationService.showCallNotification(this, rc.name, rc.number,&#10;                            androidx.core.content.ContextCompat.checkSelfPermission(&#10;                                    this, android.Manifest.permission.CALL_PHONE)&#10;                                    == android.content.pm.PackageManager.PERMISSION_GRANTED);&#10;                    sayViaWakeService(&quot;Desbloqueá y tocá la notificación para llamar a &quot; + rc.name + &quot;.&quot;, 0);&#10;                    postWatchdog(8000);&#10;                    stopSelf(); return;&#10;                }&#10;&#10;                boolean hasCall = androidx.core.content.ContextCompat.checkSelfPermission(&#10;                        this, android.Manifest.permission.CALL_PHONE)&#10;                        == android.content.pm.PackageManager.PERMISSION_GRANTED;&#10;&#10;                if (!hasCall &amp;&amp; !AppState.isDefaultDialer(this)) {&#10;                    NotificationService.showCallNotification(this, rc.name, rc.number, hasCall);&#10;                    sayViaWakeService(&quot;Tocá la notificación para llamar a &quot; + rc.name + &quot;.&quot;, 0);&#10;                    postWatchdog(8000);&#10;                    stopSelf(); return;&#10;                }&#10;&#10;                PhoneCallExecutor calls = new PhoneCallExecutor(this);&#10;                boolean ok = calls.placeDirectCall(rc.name, rc.number, AppState.isDefaultDialer(this));&#10;                if (ok) sayViaWakeService(&quot;Llamando a &quot; + rc.name + &quot;.&quot;, 0);&#10;                else {&#10;                    NotificationService.showCallNotification(this, rc.name, rc.number, hasCall);&#10;                    sayViaWakeService(&quot;No pude iniciar la llamada directa. Te dejé una notificación para marcar.&quot;, 0);&#10;                }&#10;&#10;                postWatchdog(8000);&#10;                stopSelf(); return;&#10;            }&#10;&#10;            case &quot;SEND_MESSAGE&quot;: {&#10;                if (FallSignals.isActive()) { stopSelf(); return; }&#10;                String who = (nres != null &amp;&amp; nres.slots != null) ? nres.slots.contact_query : null;&#10;                String msg = (nres != null &amp;&amp; nres.slots != null) ? nres.slots.message_text : null;&#10;&#10;                if ((who == null || who.isBlank()) || (msg == null || msg.isBlank())) {&#10;                    FallbackMessage fm = fallbackExtractMessage(transcript);&#10;                    if (who == null || who.isBlank()) who = (fm != null ? fm.who : null);&#10;                    if (msg == null || msg.isBlank()) msg = (fm != null ? fm.text : null);&#10;                }&#10;&#10;                if (who == null || who.trim().isEmpty()) {&#10;                    sayViaWakeService(&quot;¿A quién querés mandarle el mensaje?&quot;, 0);&#10;                    stopSelf(); return;&#10;                }&#10;&#10;                boolean hasContacts = androidx.core.content.ContextCompat.checkSelfPermission(&#10;                        this, android.Manifest.permission.READ_CONTACTS)&#10;                        == android.content.pm.PackageManager.PERMISSION_GRANTED;&#10;&#10;                if (!hasContacts) {&#10;                    sayViaWakeService(&quot;Necesito permiso de contactos para mandar por nombre. Abrí la app para darlo.&quot;, 0);&#10;                    Intent perm = new Intent(this, com.example.toto_app.MainActivity.class)&#10;                            .addFlags(Intent.FLAG_ACTIVITY_NEW_TASK)&#10;                            .putExtra(&quot;request_contacts_perm&quot;, true);&#10;                    startActivity(perm);&#10;                    postWatchdog(8000);&#10;                    stopSelf(); return;&#10;                }&#10;&#10;                DeviceActions.ResolvedContact rc = DeviceActions.resolveContactByNameFuzzy(this, who);&#10;                if (rc == null || rc.number == null || rc.number.isEmpty()) {&#10;                    sayViaWakeService(&quot;No encontré a &quot; + who + &quot; en tus contactos.&quot;, 0);&#10;                    stopSelf(); return;&#10;                }&#10;&#10;                if (msg == null || msg.trim().isEmpty()) {&#10;                    sayViaWakeService(&quot;¿Qué querés que le diga a &quot; + rc.name + &quot;?&quot;, 0);&#10;                    stopSelf(); return;&#10;                }&#10;&#10;                String to = rc.number.replaceAll(&quot;[^0-9+]&quot;, &quot;&quot;);&#10;                try {&#10;                    com.example.toto_app.network.WhatsAppSendRequest wreq =&#10;                            new com.example.toto_app.network.WhatsAppSendRequest(to, msg.trim(), Boolean.FALSE);&#10;                    retrofit2.Response&lt;com.example.toto_app.network.WhatsAppSendResponse&gt; wresp =&#10;                            RetrofitClient.api().waSend(wreq).execute();&#10;&#10;                    com.example.toto_app.network.WhatsAppSendResponse wbody = wresp.body();&#10;                    boolean ok =&#10;                            wresp.isSuccessful()&#10;                                    &amp;&amp; wbody != null&#10;                                    &amp;&amp; (&quot;ok&quot;.equalsIgnoreCase(wbody.status)&#10;                                    || &quot;ok_template&quot;.equalsIgnoreCase(wbody.status)&#10;                                    || (wbody.id != null &amp;&amp; !wbody.id.trim().isEmpty()));&#10;&#10;                    if (ok) sayViaWakeService(&quot;Listo, le mandé el mensaje a &quot; + rc.name + &quot;.&quot;, 0);&#10;                    else {&#10;                        String err = null;&#10;                        try { err = (wresp.errorBody() != null) ? wresp.errorBody().string() : null; } catch (Exception ignored) {}&#10;                        Log.e(TAG, &quot;WA send failed: HTTP=&quot; + (wresp != null ? wresp.code() : -1)&#10;                                + &quot; status=&quot; + (wbody != null ? wbody.status : &quot;null&quot;)&#10;                                + &quot; id=&quot; + (wbody != null ? wbody.id : &quot;null&quot;)&#10;                                + &quot; err=&quot; + err);&#10;                        if (err != null &amp;&amp; (err.contains(&quot;recipient_not_allowed&quot;) || err.contains(&quot;131030&quot;)))&#10;                            sayViaWakeService(&quot;No pude enviar por WhatsApp porque ese número no está autorizado aún.&quot;, 0);&#10;                        else&#10;                            sayViaWakeService(&quot;No pude mandar el mensaje ahora.&quot;, 0);&#10;                    }&#10;                } catch (Exception ex) {&#10;                    Log.e(TAG, &quot;Error /api/whatsapp/send&quot;, ex);&#10;                    sayViaWakeService(&quot;Tuve un problema mandando el mensaje.&quot;, 0);&#10;                }&#10;&#10;                stopSelf(); return;&#10;            }&#10;&#10;            case &quot;SPOTIFY_PLAY&quot;: {&#10;                if (FallSignals.isActive()) { stopSelf(); return; }&#10;                String query = (nres != null &amp;&amp; nres.slots != null) ? nres.slots.message_text : null;&#10;                if (query == null || query.isBlank()) {&#10;                    sayViaWakeService(&quot;¿Qué querés escuchar en Spotify?&quot;, 0);&#10;                    stopSelf(); return;&#10;                }&#10;&#10;                try {&#10;                    retrofit2.Response&lt;SpotifyStatus&gt; s = RetrofitClient.api().spotifyStatus().execute();&#10;                    SpotifyStatus st = s.isSuccessful() ? s.body() : null;&#10;                    if (st == null) { sayViaWakeService(&quot;No pude verificar Spotify ahora.&quot;, 0); stopSelf(); return; }&#10;&#10;                    if (!Boolean.TRUE.equals(st.connected)) {&#10;                        String url = st.loginUrl;&#10;                        Intent i = new Intent(Intent.ACTION_VIEW, android.net.Uri.parse(url));&#10;                        i.addFlags(Intent.FLAG_ACTIVITY_NEW_TASK);&#10;                        android.app.PendingIntent pi = android.app.PendingIntent.getActivity(&#10;                                this, 1001, i,&#10;                                android.app.PendingIntent.FLAG_UPDATE_CURRENT | android.app.PendingIntent.FLAG_IMMUTABLE);&#10;                        NotificationService.simpleActionNotification(this, &quot;Conectar Spotify&quot;,&#10;                                &quot;Tocá para vincular tu cuenta de Spotify.&quot;, pi);&#10;                        sayViaWakeService(&quot;Necesito conectar tu Spotify. Tocá la notificación para autorizar.&quot;, 0);&#10;                        postWatchdog(8000); stopSelf(); return;&#10;                    }&#10;&#10;                    if (st.premium != null &amp;&amp; !st.premium) {&#10;                        sayViaWakeService(&quot;Tu cuenta de Spotify no es Premium.&quot;, 0);&#10;                        stopSelf(); return;&#10;                    }&#10;&#10;                    if (st.deviceCount == null || st.deviceCount == 0) {&#10;                        boolean activated = ensureSpotifyDeviceActivated(query, /*timeoutMs=*/8000);&#10;                        if (!activated) {&#10;                            sayViaWakeService(&quot;No encuentro un dispositivo de Spotify. Abrí Spotify una vez y volvemos a intentar.&quot;, 0);&#10;                            stopSelf(); return;&#10;                        }&#10;                    }&#10;&#10;                    java.util.Map&lt;String,String&gt; body = new java.util.HashMap&lt;&gt;();&#10;                    body.put(&quot;query&quot;, query);&#10;                    if (st.suggestedDeviceId != null &amp;&amp; !st.suggestedDeviceId.isEmpty()) {&#10;                        body.put(&quot;deviceId&quot;, st.suggestedDeviceId);&#10;                    }&#10;&#10;                    retrofit2.Response&lt;com.google.gson.JsonObject&gt; r = RetrofitClient.api().spotifyPlay(body).execute();&#10;                    if (r.isSuccessful()) {&#10;                        signalCmdFinishedNow();&#10;                        signalCmdFinishedLater(1500);&#10;                    } else {&#10;                        String err = null;&#10;                        try { err = (r.errorBody() != null) ? r.errorBody().string() : null; } catch (Exception ignore) {}&#10;                        String speak = &quot;No pude reproducir en Spotify ahora.&quot;;&#10;                        if (err != null) {&#10;                            if (err.contains(&quot;NOT_LOGGED_IN&quot;)) speak = &quot;Necesitás conectar tu Spotify.&quot;;&#10;                            else if (err.contains(&quot;PREMIUM_REQUIRED&quot;)) speak = &quot;Tu cuenta de Spotify no es Premium.&quot;;&#10;                            else if (err.contains(&quot;NO_DEVICE&quot;)) speak = &quot;No hay un dispositivo de Spotify activo.&quot;;&#10;                            else if (err.contains(&quot;SEARCH_EMPTY&quot;)) speak = &quot;No encontré ese tema en Spotify.&quot;;&#10;                        }&#10;                        sayViaWakeService(speak, 0);&#10;                    }&#10;&#10;                } catch (Exception ex) {&#10;                    Log.e(TAG, &quot;Spotify play error&quot;, ex);&#10;                    sayViaWakeService(&quot;Tuve un problema con Spotify.&quot;, 0);&#10;                }&#10;&#10;                stopSelf(); return;&#10;            }&#10;&#10;            case &quot;SPOTIFY_PAUSE&quot;: {&#10;                if (FallSignals.isActive()) { stopSelf(); return; }&#10;                try {&#10;                    retrofit2.Response&lt;SpotifyResponse&gt; r = RetrofitClient.api().spotifyPause().execute();&#10;                    if (r.code() == 401 || r.code() == 403) {&#10;                        sayViaWakeService(&quot;Necesitás vincular tu cuenta de Spotify en la app.&quot;, 0);&#10;                    } else if (!isOk(r)) {&#10;                        sayViaWakeService(&quot;No pude pausar Spotify.&quot;, 0);&#10;                    }&#10;                } catch (Exception ex) {&#10;                    Log.e(TAG, &quot;Error /api/spotify/pause&quot;, ex);&#10;                    sayViaWakeService(&quot;Tuve un problema con Spotify.&quot;, 0);&#10;                }&#10;                stopSelf(); return;&#10;            }&#10;&#10;            case &quot;SPOTIFY_RESUME&quot;: {&#10;                if (FallSignals.isActive()) { stopSelf(); return; }&#10;                sayViaWakeService(&quot;No pude continuar la reproducción.&quot;, 0);&#10;                stopSelf(); return;&#10;            }&#10;&#10;            case &quot;SPOTIFY_NEXT&quot;: {&#10;                if (FallSignals.isActive()) { stopSelf(); return; }&#10;                try {&#10;                    retrofit2.Response&lt;SpotifyResponse&gt; r = RetrofitClient.api().spotifyNext().execute();&#10;                    if (r.code() == 401 || r.code() == 403) {&#10;                        sayViaWakeService(&quot;Necesitás vincular tu cuenta de Spotify en la app.&quot;, 0);&#10;                    } else if (!isOk(r)) {&#10;                        sayViaWakeService(&quot;No pude pasar al siguiente.&quot;, 0);&#10;                    }&#10;                } catch (Exception ex) {&#10;                    Log.e(TAG, &quot;Error /api/spotify/next&quot;, ex);&#10;                    sayViaWakeService(&quot;Tuve un problema con Spotify.&quot;, 0);&#10;                }&#10;                stopSelf(); return;&#10;            }&#10;&#10;            case &quot;SPOTIFY_PREV&quot;: {&#10;                if (FallSignals.isActive()) { stopSelf(); return; }&#10;                try {&#10;                    retrofit2.Response&lt;SpotifyResponse&gt; r = RetrofitClient.api().spotifyPrev().execute();&#10;                    if (r.code() == 401 || r.code() == 403) {&#10;                        sayViaWakeService(&quot;Necesitás vincular tu cuenta de Spotify en la app.&quot;, 0);&#10;                    } else if (!isOk(r)) {&#10;                        sayViaWakeService(&quot;No pude volver al anterior.&quot;, 0);&#10;                    }&#10;                } catch (Exception ex) {&#10;                    Log.e(TAG, &quot;Error /api/spotify/prev&quot;, ex);&#10;                    sayViaWakeService(&quot;Tuve un problema con Spotify.&quot;, 0);&#10;                }&#10;                stopSelf(); return;&#10;            }&#10;&#10;            case &quot;SPOTIFY_SET_VOLUME&quot;: {&#10;                if (FallSignals.isActive()) { stopSelf(); return; }&#10;                String v = (nres != null &amp;&amp; nres.slots != null) ? nres.slots.message_text : null;&#10;                if (v == null || v.trim().isEmpty()) v = &quot;up&quot;;&#10;                try {&#10;                    retrofit2.Response&lt;SpotifyResponse&gt; r =&#10;                            RetrofitClient.api().spotifyVolume(new SpotifyVolumeRequest(v.trim())).execute();&#10;                    if (r.code() == 401 || r.code() == 403) {&#10;                        sayViaWakeService(&quot;Necesitás vincular tu cuenta de Spotify en la app.&quot;, 0);&#10;                    } else if (!isOk(r)) {&#10;                        sayViaWakeService(&quot;No pude ajustar el volumen en Spotify.&quot;, 0);&#10;                    }&#10;                } catch (Exception ex) {&#10;                    Log.e(TAG, &quot;Error /api/spotify/volume&quot;, ex);&#10;                    sayViaWakeService(&quot;Tuve un problema con Spotify.&quot;, 0);&#10;                }&#10;                stopSelf(); return;&#10;            }&#10;&#10;            case &quot;SPOTIFY_SET_SHUFFLE&quot;: {&#10;                if (FallSignals.isActive()) { stopSelf(); return; }&#10;                String state = (nres != null &amp;&amp; nres.slots != null) ? nres.slots.message_text : null;&#10;                if (state == null || state.isBlank()) state = &quot;on&quot;;&#10;                try {&#10;                    retrofit2.Response&lt;SpotifyResponse&gt; r =&#10;                            RetrofitClient.api().spotifyShuffle(new SpotifyShuffleRequest(state)).execute();&#10;                    if (r.code() == 401 || r.code() == 403) {&#10;                        sayViaWakeService(&quot;Necesitás vincular tu cuenta de Spotify en la app.&quot;, 0);&#10;                    } else if (!isOk(r)) {&#10;                        sayViaWakeService(&quot;No pude cambiar el modo aleatorio.&quot;, 0);&#10;                    }&#10;                } catch (Exception ex) {&#10;                    Log.e(TAG, &quot;Error /api/spotify/shuffle&quot;, ex);&#10;                    sayViaWakeService(&quot;Tuve un problema con Spotify.&quot;, 0);&#10;                }&#10;                stopSelf(); return;&#10;            }&#10;&#10;            case &quot;SPOTIFY_SET_REPEAT&quot;: {&#10;                if (FallSignals.isActive()) { stopSelf(); return; }&#10;                String state = (nres != null &amp;&amp; nres.slots != null) ? nres.slots.message_text : null;&#10;                if (state == null || state.isBlank()) state = &quot;track&quot;;&#10;                try {&#10;                    retrofit2.Response&lt;SpotifyResponse&gt; r =&#10;                            RetrofitClient.api().spotifyRepeat(new SpotifyRepeatRequest(state)).execute();&#10;                    if (r.code() == 401 || r.code() == 403) {&#10;                        sayViaWakeService(&quot;Necesitás vincular tu cuenta de Spotify en la app.&quot;, 0);&#10;                    } else if (!isOk(r)) {&#10;                        sayViaWakeService(&quot;No pude cambiar el modo de repetición.&quot;, 0);&#10;                    }&#10;                } catch (Exception ex) {&#10;                    Log.e(TAG, &quot;Error /api/spotify/repeat&quot;, ex);&#10;                    sayViaWakeService(&quot;Tuve un problema con Spotify.&quot;, 0);&#10;                }&#10;                stopSelf(); return;&#10;            }&#10;&#10;            case &quot;CANCEL&quot;: {&#10;                if (FallSignals.isActive()) { stopSelf(); return; }&#10;                sayViaWakeService(&quot;Listo.&quot;, 0);&#10;                stopSelf(); return;&#10;            }&#10;            case &quot;ANSWER&quot;:&#10;            case &quot;UNKNOWN&quot;:&#10;            default: {&#10;                if (FallSignals.isActive()) { stopSelf(); return; }&#10;                try {&#10;                    AskRequest rq = new AskRequest();&#10;                    rq.prompt = transcript;&#10;                    Response&lt;AskResponse&gt; r2 = RetrofitClient.api().ask(rq).execute();&#10;                    String reply = (r2.isSuccessful() &amp;&amp; r2.body() != null &amp;&amp; r2.body().reply != null)&#10;                            ? r2.body().reply.trim()&#10;                            : &quot;No estoy seguro, ¿podés repetir?&quot;;&#10;                    sayViaWakeService(TtsSanitizer.sanitizeForTTS(reply), 0);&#10;                } catch (Exception ex) {&#10;                    Log.e(TAG, &quot;Error /api/ask&quot;, ex);&#10;                    sayViaWakeService(&quot;Tuve un problema procesando eso.&quot;, 0);&#10;                }&#10;                stopSelf(); return;&#10;            }&#10;        }&#10;    }&#10;&#10;    private void sayThenListenHere(String text, @Nullable String nextFallMode) {&#10;        Intent say = new Intent(this, WakeWordService.class)&#10;                .setAction(WakeWordService.ACTION_SAY)&#10;                .putExtra(&quot;text&quot;, TtsSanitizer.sanitizeForTTS(text))&#10;                .putExtra(WakeWordService.EXTRA_AFTER_SAY_START_SERVICE, true)&#10;                .putExtra(WakeWordService.EXTRA_AFTER_SAY_USER_NAME, userName);&#10;        if (nextFallMode != null) {&#10;            say.putExtra(WakeWordService.EXTRA_AFTER_SAY_FALL_MODE, nextFallMode);&#10;        }&#10;        androidx.core.content.ContextCompat.startForegroundService(this, say);&#10;    }&#10;&#10;    private void handleAlarmResult(DeviceActions.AlarmResult res, String when) {&#10;        switch (res) {&#10;            case SET_SILENT:&#10;                sayViaWakeService(&quot;Listo, te pongo una alarma para las &quot; + when + &quot;.&quot;, 0);&#10;                break;&#10;            case UI_ACTION_REQUIRED:&#10;                sayViaWakeService(&quot;Te dejé una notificación para confirmar la alarma de las &quot; + when + &quot;.&quot;, 0);&#10;                break;&#10;            default:&#10;                sayViaWakeService(&quot;No pude crear la alarma. Fijate permisos del reloj.&quot;, 0);&#10;                break;&#10;        }&#10;    }&#10;&#10;    private void sayViaWakeService(String text, int watchdogMs) {&#10;        Intent say = new Intent(this, WakeWordService.class)&#10;                .setAction(WakeWordService.ACTION_SAY)&#10;                .putExtra(&quot;text&quot;, text);&#10;        androidx.core.content.ContextCompat.startForegroundService(this, say);&#10;        if (watchdogMs &gt; 0) postWatchdog(watchdogMs);&#10;    }&#10;&#10;    private void postWatchdog(int ms) {&#10;        new android.os.Handler(getMainLooper()).postDelayed(() -&gt;&#10;                sendBroadcast(new Intent(WakeWordService.ACTION_CMD_FINISHED)), ms);&#10;    }&#10;&#10;    private void signalCmdFinishedNow() {&#10;        Intent svc = new Intent(this, WakeWordService.class)&#10;                .setAction(WakeWordService.ACTION_CMD_FINISHED)&#10;                .putExtra(&quot;reason&quot;, &quot;SPOTIFY_PLAY_OK&quot;);&#10;        androidx.core.content.ContextCompat.startForegroundService(this, svc);&#10;&#10;        sendBroadcast(new Intent(WakeWordService.ACTION_CMD_FINISHED)&#10;                .putExtra(&quot;reason&quot;, &quot;SPOTIFY_PLAY_OK&quot;));&#10;    }&#10;&#10;    private void signalCmdFinishedLater(int delayMs) {&#10;        new android.os.Handler(getMainLooper()).postDelayed(() -&gt; {&#10;            Intent svc = new Intent(this, WakeWordService.class)&#10;                    .setAction(WakeWordService.ACTION_CMD_FINISHED)&#10;                    .putExtra(&quot;reason&quot;, &quot;SPOTIFY_PLAY_OK_DELAYED&quot;);&#10;            androidx.core.content.ContextCompat.startForegroundService(this, svc);&#10;&#10;            sendBroadcast(new Intent(WakeWordService.ACTION_CMD_FINISHED)&#10;                    .putExtra(&quot;reason&quot;, &quot;SPOTIFY_PLAY_OK_DELAYED&quot;));&#10;        }, Math.max(150, delayMs));&#10;    }&#10;&#10;    @Nullable @Override public IBinder onBind(Intent intent) { return null; }&#10;    @Override public void onDestroy() { super.onDestroy(); }&#10;&#10;    @Nullable&#10;    private static int[] tryParseIsoToLocalHourMinute(String iso) {&#10;        if (iso == null || iso.isEmpty()) return null;&#10;        String[] patterns = new String[] {&#10;                &quot;yyyy-MM-dd'T'HH:mm:ss.SSSXXX&quot;,&#10;                &quot;yyyy-MM-dd'T'HH:mm:ssXXX&quot;,&#10;                &quot;yyyy-MM-dd'T'HH:mmXXX&quot;,&#10;                &quot;yyyy-MM-dd'T'HH:mm:ss'Z'&quot;,&#10;                &quot;yyyy-MM-dd'T'HH:mm'Z'&quot;,&#10;                &quot;yyyy-MM-dd'T'HH:mm:ss&quot;,&#10;                &quot;yyyy-MM-dd'T'HH:mm&quot;&#10;        };&#10;        for (String p : patterns) {&#10;            try {&#10;                SimpleDateFormat sdf = new SimpleDateFormat(p, Locale.US);&#10;                if (!p.endsWith(&quot;XXX&quot;)) {&#10;                    sdf.setTimeZone(TimeZone.getTimeZone(&quot;UTC&quot;));&#10;                }&#10;                Date d = sdf.parse(iso);&#10;                if (d != null) {&#10;                    Calendar cal = Calendar.getInstance();&#10;                    cal.setTime(d);&#10;                    return new int[]{ cal.get(Calendar.HOUR_OF_DAY), cal.get(Calendar.MINUTE) };&#10;                }&#10;            } catch (ParseException ignored) { }&#10;        }&#10;        return null;&#10;    }&#10;&#10;    private static String capitalizeFirst(String s, Locale loc) {&#10;        if (s == null || s.isEmpty()) return s;&#10;        return s.substring(0, 1).toUpperCase(loc) + s.substring(1);&#10;    }&#10;&#10;    private static String safe(String s) { return (s == null) ? &quot;null&quot; : s; }&#10;&#10;    private static String slotsToString(NluRouteResponse.Slots s) {&#10;        if (s == null) return &quot;{}&quot;;&#10;        return &quot;{contact=&quot; + safe(s.contact_query) +&#10;                &quot;, hour=&quot; + s.hour +&#10;                &quot;, minute=&quot; + s.minute +&#10;                &quot;, dt=&quot; + safe(s.datetime_iso) +&#10;                &quot;, msg=&quot; + safe(s.message_text) +&#10;                &quot;, app=&quot; + safe(s.app_name) + &quot;}&quot;;&#10;    }&#10;&#10;    private static boolean looksLikePhoneNumber(String s) {&#10;        if (s == null) return false;&#10;        String t = s.replaceAll(&quot;[^0-9+]&quot;, &quot;&quot;);&#10;        return t.length() &gt;= 6;&#10;    }&#10;&#10;    private static String normalizeDialable(String s) {&#10;        if (s == null) return &quot;&quot;;&#10;        return s.replaceAll(&quot;[^0-9+]&quot;, &quot;&quot;);&#10;    }&#10;&#10;    private static final class FallbackMessage {&#10;        final String who; final String text;&#10;        FallbackMessage(String who, String text) { this.who = who; this.text = text; }&#10;    }&#10;&#10;    @Nullable&#10;    private static FallbackMessage fallbackExtractMessage(String raw) {&#10;        if (raw == null) return null;&#10;        String s = java.text.Normalizer.normalize(raw, java.text.Normalizer.Form.NFD)&#10;                .replaceAll(&quot;\\p{M}&quot;, &quot;&quot;)&#10;                .toLowerCase(java.util.Locale.ROOT)&#10;                .replaceAll(&quot;[“”\&quot;']&quot;, &quot;&quot;)&#10;                .replaceAll(&quot;\\s+&quot;, &quot; &quot;)&#10;                .trim();&#10;&#10;        String[] pats = new String[] {&#10;                &quot;\\b(?:mandale|manda|mandar|escribile|escribe|escribir|decile|decime|dile|avisale|avisa|avisar)(?:\\s+un\\s+mensaje)?\\s+a\\s+([a-z0-9ñáéíóúü\\s.-]{1,40})\\s*(?:que|de que|diciendole|diciendole que|:|–|-)\\s*(.+)$&quot;,&#10;                &quot;\\b(?:mandale|manda|escribile|decile|avisale)(?:\\s+por\\s+whatsapp)?\\s+a\\s+([a-z0-9ñáéíóúü\\s.-]{1,40})\\s+(.*)$&quot;,&#10;                &quot;\\b(?:mensaje|msj)\\s+a\\s+([a-z0-9ñáéíóúü\\s.-]{1,40})\\s*(?:que|:)?\\s*(.+)$&quot;&#10;        };&#10;&#10;        for (String p : pats) {&#10;            java.util.regex.Matcher m = java.util.regex.Pattern.compile(p).matcher(s);&#10;            if (m.find()) {&#10;                String who = cleanPerson(m.group(1));&#10;                String text = cleanMessage(m.groupCount() &gt;= 2 ? m.group(2) : &quot;&quot;);&#10;                if (!who.isEmpty() &amp;&amp; !text.isEmpty()) return new FallbackMessage(who, text);&#10;            }&#10;        }&#10;&#10;        java.util.regex.Matcher m2 = java.util.regex.Pattern&#10;                .compile(&quot;\\b(?:mandale|manda|escribile|decile|dile|avisale)\\s+a\\s+([a-z0-9ñáéíóúü\\s.-]{1,40})\\b&quot;)&#10;                .matcher(s);&#10;        if (m2.find()) {&#10;            String who = cleanPerson(m2.group(1));&#10;            if (!who.isEmpty()) return new FallbackMessage(who, &quot;&quot;);&#10;        }&#10;        return null;&#10;    }&#10;&#10;    private static String cleanPerson(String s) {&#10;        if (s == null) return &quot;&quot;;&#10;        s = s.replaceAll(&quot;(?:\\s+por\\s+favor.*$)|(?:\\s+gracias.*$)|(?:\\s+ahora.*$)|(?:\\s+urgente.*$)|(?:\\s+ya.*$)&quot;, &quot; &quot;);&#10;        s = s.replaceAll(&quot;[^a-z0-9ñáéíóúü\\s.-]&quot;, &quot; &quot;);&#10;        s = s.replaceAll(&quot;\\s+&quot;, &quot; &quot;).trim();&#10;        if (s.startsWith(&quot;a&quot;) &amp;&amp; s.length() &gt;= 2 &amp;&amp; &quot;bcdfghjklmnñpqrstvwxyz&quot;.indexOf(s.charAt(1)) &gt;= 0) {&#10;            s = s.substring(1);&#10;        }&#10;        String[] tok = s.split(&quot;\\s+&quot;);&#10;        int limit = Math.min(tok.length, 4);&#10;        StringBuilder out = new StringBuilder();&#10;        for (int i = 0; i &lt; limit; i++) { if (i &gt; 0) out.append(' '); out.append(tok[i]); }&#10;        return out.toString();&#10;    }&#10;&#10;    private static String cleanMessage(String s) {&#10;        if (s == null) return &quot;&quot;;&#10;        s = s.replaceAll(&quot;\\s+&quot;, &quot; &quot;).trim();&#10;        s = s.replaceAll(&quot;(\\s+por\\s+favor.*$)|(\\s+gracias.*$)&quot;, &quot;&quot;).trim();&#10;        return s;&#10;    }&#10;&#10;    private static boolean isOk(retrofit2.Response&lt;SpotifyResponse&gt; r) {&#10;        if (r == null) return false;&#10;        if (!r.isSuccessful()) return false;&#10;        SpotifyResponse b = r.body();&#10;        if (b == null) return true;&#10;        if (b.ok != null) return b.ok;&#10;        if (b.status != null) return &quot;ok&quot;.equalsIgnoreCase(b.status) || &quot;success&quot;.equalsIgnoreCase(b.status);&#10;        return true;&#10;    }&#10;&#10;    private boolean tryOpenSpotifyNow(String query) {&#10;        try {&#10;            Intent open = new Intent(Intent.ACTION_VIEW,&#10;                    android.net.Uri.parse(&quot;spotify:search:&quot; + android.net.Uri.encode(query)));&#10;            open.addFlags(Intent.FLAG_ACTIVITY_NEW_TASK);&#10;            startActivity(open);&#10;            return true;&#10;        } catch (Exception e) {&#10;            Log.w(TAG, &quot;No pude abrir Spotify con URI (cae a abrir paquete): &quot; + e.getMessage());&#10;            try {&#10;                Intent fallback = getPackageManager().getLaunchIntentForPackage(&quot;com.spotify.music&quot;);&#10;                if (fallback != null) {&#10;                    fallback.addFlags(Intent.FLAG_ACTIVITY_NEW_TASK);&#10;                    startActivity(fallback);&#10;                    return true;&#10;                }&#10;            } catch (Exception e2) {&#10;                Log.e(TAG, &quot;No pude abrir Spotify app: &quot;, e2);&#10;            }&#10;        }&#10;        return false;&#10;    }&#10;&#10;    private boolean ensureSpotifyDeviceActivated(String query, int timeoutMs) {&#10;        long deadline = SystemClock.uptimeMillis() + Math.max(2000, timeoutMs);&#10;&#10;        boolean canLaunchNow = AppState.isAppInForeground(this) &amp;&amp; !AppState.isDeviceLocked(this);&#10;        if (canLaunchNow) {&#10;            tryOpenSpotifyNow(query);&#10;        } else {&#10;            Intent open = getPackageManager().getLaunchIntentForPackage(&quot;com.spotify.music&quot;);&#10;            if (open != null) {&#10;                open.addFlags(Intent.FLAG_ACTIVITY_NEW_TASK);&#10;                android.app.PendingIntent pi = android.app.PendingIntent.getActivity(&#10;                        this, 1002, open,&#10;                        android.app.PendingIntent.FLAG_UPDATE_CURRENT | android.app.PendingIntent.FLAG_IMMUTABLE);&#10;                NotificationService.simpleActionNotification(&#10;                        this, &quot;Abrir Spotify&quot;, &quot;Tocá para activar un dispositivo.&quot;, pi);&#10;            }&#10;        }&#10;&#10;        while (SystemClock.uptimeMillis() &lt; deadline) {&#10;            try {&#10;                retrofit2.Response&lt;SpotifyStatus&gt; s = RetrofitClient.api().spotifyStatus().execute();&#10;                SpotifyStatus st = s.isSuccessful() ? s.body() : null;&#10;                if (st != null &amp;&amp; Boolean.TRUE.equals(st.connected)) {&#10;                    Integer dc = st.deviceCount;&#10;                    if (dc != null &amp;&amp; dc &gt; 0) return true;&#10;                }&#10;            } catch (Exception e) {&#10;                Log.w(TAG, &quot;Polling spotifyStatus: &quot; + e.getMessage());&#10;            }&#10;            try { Thread.sleep(800); } catch (InterruptedException ignored) {}&#10;        }&#10;        return false;&#10;    }&#10;}&#10;" />
              <option name="updatedContent" value="package com.example.toto_app.services;&#10;&#10;import android.content.Intent;&#10;import android.os.IBinder;&#10;import android.os.SystemClock;&#10;import android.util.Log;&#10;&#10;import androidx.annotation.Nullable;&#10;&#10;import com.example.toto_app.actions.DeviceActions;&#10;import com.example.toto_app.audio.InstructionCapture;&#10;import com.example.toto_app.audio.VadUtils;&#10;import com.example.toto_app.calls.AppState;&#10;import com.example.toto_app.calls.PhoneCallExecutor;&#10;import com.example.toto_app.falls.FallLogic;&#10;import com.example.toto_app.falls.FallSignals;&#10;import com.example.toto_app.network.AskRequest;&#10;import com.example.toto_app.network.AskResponse;&#10;import com.example.toto_app.network.NluRouteResponse;&#10;import com.example.toto_app.network.RetrofitClient;&#10;import com.example.toto_app.network.SpotifyRepeatRequest;&#10;import com.example.toto_app.network.SpotifyResponse;&#10;import com.example.toto_app.network.SpotifyShuffleRequest;&#10;import com.example.toto_app.network.SpotifyStatus;&#10;import com.example.toto_app.network.SpotifyVolumeRequest;&#10;import com.example.toto_app.nlp.NluResolver;&#10;import com.example.toto_app.stt.SttClient;&#10;import com.example.toto_app.util.TtsSanitizer;&#10;&#10;import java.io.File;&#10;import java.text.ParseException;&#10;import java.text.SimpleDateFormat;&#10;import java.util.Calendar;&#10;import java.util.Date;&#10;import java.util.Locale;&#10;import java.util.TimeZone;&#10;import java.util.concurrent.Executors;&#10;&#10;import retrofit2.Response;&#10;&#10;public class InstructionService extends android.app.Service {&#10;&#10;    private static final String TAG = &quot;InstructionService&quot;;&#10;&#10;    private String userName = &quot;Juan&quot;;&#10;&#10;    private static final String EXTRA_FALL_MODE = &quot;fall_mode&quot;;&#10;    @Nullable private String fallMode = null;&#10;    private int fallRetry = 0;&#10;&#10;    private static final String EMERGENCY_NAME   = &quot;Tamara&quot;;&#10;    private static final String EMERGENCY_NUMBER = &quot;+5491159753115&quot;;&#10;    private boolean fallOwner = false;&#10;&#10;    @Override public void onCreate() { super.onCreate(); }&#10;&#10;    @Override&#10;    public int onStartCommand(Intent intent, int flags, int startId) {&#10;        if (intent != null) {&#10;            if (intent.hasExtra(&quot;user_name&quot;)) {&#10;                String incoming = intent.getStringExtra(&quot;user_name&quot;);&#10;                if (incoming != null &amp;&amp; !incoming.trim().isEmpty()) userName = incoming.trim();&#10;            }&#10;            if (intent.hasExtra(EXTRA_FALL_MODE)) {&#10;                String fmRaw = intent.getStringExtra(EXTRA_FALL_MODE);&#10;                if (fmRaw != null &amp;&amp; !fmRaw.trim().isEmpty()) {&#10;                    String upper = fmRaw.trim().toUpperCase(Locale.ROOT);&#10;                    String[] parts = upper.split(&quot;:&quot;, 2);&#10;                    fallMode = parts[0];&#10;                    if (parts.length &gt; 1) {&#10;                        try { fallRetry = Integer.parseInt(parts[1]); } catch (Exception ignore) {}&#10;                    }&#10;                }&#10;            }&#10;        }&#10;&#10;        if (fallMode != null) {&#10;            if (!FallSignals.isActive()) {&#10;                FallSignals.tryActivate();&#10;            }&#10;            fallOwner = true;&#10;        } else {&#10;            if (FallSignals.isActive()) {&#10;                stopSelf();&#10;                return START_NOT_STICKY;&#10;            }&#10;        }&#10;&#10;        Executors.newSingleThreadExecutor().execute(this::doWork);&#10;        return START_NOT_STICKY;&#10;    }&#10;&#10;    private void doWork() {&#10;        if (fallMode == null &amp;&amp; FallSignals.isActive()) {&#10;            stopSelf();&#10;            return;&#10;        }&#10;&#10;        if (&quot;CHECK&quot;.equals(fallMode)) {&#10;            String prompt = &quot;Escuché un golpe. ¿Estás bien?&quot;;&#10;            sayThenListenHere(prompt, &quot;AWAIT:0&quot;);&#10;            stopSelf();&#10;            return;&#10;        }&#10;&#10;        File cacheDir = getExternalCacheDir() != null ? getExternalCacheDir() : getCacheDir();&#10;        File wav = new File(cacheDir, &quot;toto_instruction_&quot; + SystemClock.elapsedRealtime() + &quot;.wav&quot;);&#10;&#10;        InstructionCapture.Config cfg = new InstructionCapture.Config();&#10;        cfg.sampleRate = 16000;&#10;        cfg.maxDurationMs = 15000;&#10;        cfg.trailingSilenceMs = 1800;&#10;        cfg.silenceDbfs = -45.0;&#10;        cfg.frameMs = 30;&#10;&#10;        if (&quot;AWAIT&quot;.equals(fallMode) || &quot;AWAIT_ACTION&quot;.equals(fallMode)) {&#10;            cfg.maxDurationMs     = 12000;&#10;            cfg.trailingSilenceMs = 3500;&#10;            cfg.silenceDbfs       = -50.0;&#10;        }&#10;&#10;        Log.d(TAG, &quot;Grabando a WAV: &quot; + wav.getAbsolutePath());&#10;        InstructionCapture.captureToWav(wav, cfg, new InstructionCapture.Listener(){});&#10;&#10;        int minVoicedMs =&#10;                (&quot;AWAIT&quot;.equals(fallMode) || &quot;AWAIT_ACTION&quot;.equals(fallMode) || &quot;CHECK&quot;.equals(fallMode))&#10;                        ? 220 : 320;&#10;&#10;        if (!VadUtils.hasEnoughVoice(wav, cfg.silenceDbfs, minVoicedMs)) {&#10;            Log.d(TAG, &quot;VAD: silencio o voz insuficiente&quot;);&#10;            if (&quot;AWAIT&quot;.equals(fallMode)) {&#10;                if (fallRetry &lt;= 0) {&#10;                    sayThenListenHere(&quot;No te escuché. ¿Estás bien?&quot;, &quot;AWAIT:1&quot;);&#10;                } else {&#10;                    int res = FallLogic.sendEmergencyMessageToResult(EMERGENCY_NUMBER, userName);&#10;                    if (res == 0) sayViaWakeService(&quot;No te escuché. Ya avisé a &quot; + EMERGENCY_NAME + &quot;.&quot;, 0);&#10;                    else if (res == 1) sayViaWakeService(&quot;No hay conexión. En cuanto vuelva, enviaré el mensaje de emergencia.&quot;, 0);&#10;                    else sayViaWakeService(&quot;No te escuché y no pude avisar a &quot; + EMERGENCY_NAME + &quot;.&quot;, 0);&#10;                    if (fallOwner) {&#10;                        FallSignals.clear();&#10;                        Intent resume = new Intent(this, WakeWordService.class)&#10;                                .setAction(WakeWordService.ACTION_RESUME_LISTEN)&#10;                                .putExtra(WakeWordService.EXTRA_REASON, WakeWordService.REASON_FALL_CLEAR);&#10;                        androidx.core.content.ContextCompat.startForegroundService(this, resume);&#10;                    }&#10;                }&#10;                try { wav.delete(); } catch (Exception ignore) {}&#10;                stopSelf();&#10;                return;&#10;            } else {&#10;                sayViaWakeService(&quot;No te escuché bien.&quot;, 0);&#10;                try { wav.delete(); } catch (Exception ignore) {}&#10;                stopSelf();&#10;                return;&#10;            }&#10;        }&#10;&#10;        String transcript = &quot;&quot;;&#10;        try {&#10;            transcript = SttClient.transcribe(wav);&#10;        } finally {&#10;            try { wav.delete(); } catch (Exception ignored) {}&#10;        }&#10;&#10;        if (&quot;AWAIT&quot;.equals(fallMode)) {&#10;            String norm = FallLogic.normEs(transcript);&#10;            if (norm.isEmpty()) {&#10;                if (fallRetry &lt;= 0) {&#10;                    sayThenListenHere(&quot;No te escuché. ¿Estás bien?&quot;, &quot;AWAIT:1&quot;);&#10;                } else {&#10;                    int res = FallLogic.sendEmergencyMessageToResult(EMERGENCY_NUMBER, userName);&#10;                    if (res == 0) sayViaWakeService(&quot;No te escuché. Ya avisé a &quot; + EMERGENCY_NAME + &quot;.&quot;, 0);&#10;                    else if (res == 1) sayViaWakeService(&quot;No hay conexión. En cuanto vuelva, enviaré el mensaje de emergencia.&quot;, 0);&#10;                    else sayViaWakeService(&quot;No te escuché y no pude avisar a &quot; + EMERGENCY_NAME + &quot;.&quot;, 0);&#10;                    if (fallOwner) {&#10;                        FallSignals.clear();&#10;                        Intent resume = new Intent(this, WakeWordService.class)&#10;                                .setAction(WakeWordService.ACTION_RESUME_LISTEN)&#10;                                .putExtra(WakeWordService.EXTRA_REASON, WakeWordService.REASON_FALL_CLEAR);&#10;                        androidx.core.content.ContextCompat.startForegroundService(this, resume);&#10;                    }&#10;                }&#10;                stopSelf();&#10;                return;&#10;            }&#10;&#10;            FallLogic.FallReply fr = FallLogic.assessFallReply(norm);&#10;            switch (fr) {&#10;                case HELP: {&#10;                    int res = FallLogic.sendEmergencyMessageToResult(EMERGENCY_NUMBER, userName);&#10;                    if (res == 0) sayViaWakeService(&quot;Ya avisé a &quot; + EMERGENCY_NAME + &quot;.&quot;, 0);&#10;                    else if (res == 1) sayViaWakeService(&quot;No hay conexión. En cuanto vuelva, enviaré el mensaje de emergencia.&quot;, 0);&#10;                    else    sayViaWakeService(&quot;Quise avisar a &quot; + EMERGENCY_NAME + &quot; pero no pude enviar el mensaje.&quot;, 0);&#10;                    if (fallOwner) {&#10;                        FallSignals.clear();&#10;                        Intent resume = new Intent(this, WakeWordService.class)&#10;                                .setAction(WakeWordService.ACTION_RESUME_LISTEN)&#10;                                .putExtra(WakeWordService.EXTRA_REASON, WakeWordService.REASON_FALL_CLEAR);&#10;                        androidx.core.content.ContextCompat.startForegroundService(this, resume);&#10;                    }&#10;                    stopSelf(); return;&#10;                }&#10;                case OK: {&#10;                    sayViaWakeService(&quot;Me alegro. Si necesitás ayuda, decime.&quot;, 0);&#10;                    if (fallOwner) {&#10;                        FallSignals.clear();&#10;                        Intent resume = new Intent(this, WakeWordService.class)&#10;                                .setAction(WakeWordService.ACTION_RESUME_LISTEN)&#10;                                .putExtra(WakeWordService.EXTRA_REASON, WakeWordService.REASON_FALL_CLEAR);&#10;                        androidx.core.content.ContextCompat.startForegroundService(this, resume);&#10;                    }&#10;                    stopSelf(); return;&#10;                }&#10;                case UNKNOWN:&#10;                default: {&#10;                    sayThenListenHere(&quot;No me quedó claro. ¿Estás bien?&quot;, &quot;AWAIT:&quot; + fallRetry);&#10;                    stopSelf(); return;&#10;                }&#10;            }&#10;        }&#10;&#10;        if (transcript.isEmpty()) {&#10;            sayViaWakeService(&quot;No te escuché bien.&quot;, 0);&#10;            stopSelf();&#10;            return;&#10;        }&#10;&#10;        String normAll = FallLogic.normEs(transcript);&#10;        if (FallLogic.saysHelp(normAll) || FallLogic.mentionsFall(normAll)) {&#10;            sayThenListenHere(&quot;¿Estás bien?&quot;, &quot;AWAIT:0&quot;);&#10;            stopSelf();&#10;            return;&#10;        }&#10;&#10;        try {&#10;            String norm = java.text.Normalizer.normalize(transcript, java.text.Normalizer.Form.NFD)&#10;                    .replaceAll(&quot;\\p{M}&quot;, &quot;&quot;)&#10;                    .toLowerCase(java.util.Locale.ROOT)&#10;                    .replaceAll(&quot;[¿?¡!.,;:()\\[\\]\&quot;]&quot;, &quot; &quot;)&#10;                    .replaceAll(&quot;\\s+&quot;, &quot; &quot;)&#10;                    .trim();&#10;&#10;            boolean saysAffirm =&#10;                    norm.matches(&quot;^(si|dale|claro|ok|de una|bueno|obvio|por favor|si por favor|si dale)(\\s.*)?$&quot;);&#10;&#10;            boolean saysRead =&#10;                    norm.contains(&quot;leelo&quot;) || norm.contains(&quot;leela&quot;) ||&#10;                            norm.contains(&quot;leerlo&quot;) || norm.contains(&quot;leeme&quot;) ||&#10;                            norm.contains(&quot;leermelo&quot;) || norm.contains(&quot;leermela&quot;) ||&#10;                            norm.contains(&quot;lee el mensaje&quot;) || norm.contains(&quot;leelo por favor&quot;) ||&#10;                            norm.contains(&quot;leela por favor&quot;);&#10;&#10;            final long FRESH_MS = 3 * 60_000L;&#10;            boolean fresh = IncomingMessageStore.get().hasFresh(FRESH_MS);&#10;&#10;            if (fresh &amp;&amp; ((IncomingMessageStore.get().isAwaitingConfirm() &amp;&amp; saysAffirm) || saysRead)) {&#10;                IncomingMessageStore.Msg m = IncomingMessageStore.get().consume();&#10;                if (m != null) {&#10;                    String tts = (m.from == null ? &quot;alguien&quot; : m.from) + &quot; dice: &quot; + (m.body == null ? &quot;…&quot; : m.body);&#10;                    sayViaWakeService(tts, 0);&#10;                    stopSelf();&#10;                    return;&#10;                }&#10;            }&#10;        } catch (Throwable ignored) {}&#10;&#10;        NluRouteResponse nres = NluResolver.resolveWithFallback(transcript);&#10;        String intentName = (nres != null &amp;&amp; nres.intent != null)&#10;                ? nres.intent.trim().toUpperCase(java.util.Locale.ROOT) : &quot;UNKNOWN&quot;;&#10;&#10;        if (nres != null) {&#10;            Log.d(TAG, &quot;NLU/route → intent=&quot; + safe(nres.intent)&#10;                    + &quot; conf=&quot; + nres.confidence&#10;                    + &quot; needsConf=&quot; + nres.needs_confirmation&#10;                    + &quot; slots=&quot; + slotsToString(nres.slots)&#10;                    + &quot; ack=&quot; + safe(nres.ack_tts));&#10;        } else {&#10;            Log.d(TAG, &quot;NLU/route → nres=null&quot;);&#10;        }&#10;&#10;        if (nres != null &amp;&amp; nres.ack_tts != null &amp;&amp; !nres.ack_tts.trim().isEmpty()) {&#10;            boolean isAnswerish = &quot;ANSWER&quot;.equals(intentName) || &quot;UNKNOWN&quot;.equals(intentName);&#10;            boolean isSpotifyPlay = &quot;SPOTIFY_PLAY&quot;.equals(intentName);&#10;            boolean isFall = &quot;FALL&quot;.equals(intentName);&#10;            if (!&quot;QUERY_TIME&quot;.equals(intentName) &amp;&amp; !&quot;QUERY_DATE&quot;.equals(intentName)&#10;                    &amp;&amp; !isAnswerish &amp;&amp; !&quot;CALL&quot;.equals(intentName)&#10;                    &amp;&amp; !&quot;SEND_MESSAGE&quot;.equals(intentName)&#10;                    &amp;&amp; !isSpotifyPlay&#10;                    &amp;&amp; !isFall) {&#10;                if (!FallSignals.isActive()) {&#10;                    sayViaWakeService(TtsSanitizer.sanitizeForTTS(nres.ack_tts), 0);&#10;                } else {&#10;                    stopSelf(); return;&#10;                }&#10;            }&#10;        }&#10;&#10;        if (nres != null &amp;&amp; nres.needs_confirmation&#10;                &amp;&amp; nres.clarifying_question != null&#10;                &amp;&amp; !nres.clarifying_question.trim().isEmpty()) {&#10;&#10;            boolean actionable =&#10;                    &quot;SET_ALARM&quot;.equals(intentName) ||&#10;                            &quot;CALL&quot;.equals(intentName) ||&#10;                            &quot;SEND_MESSAGE&quot;.equals(intentName) ||&#10;                            &quot;SPOTIFY_PLAY&quot;.equals(intentName);&#10;&#10;            if (actionable) {&#10;                if (!FallSignals.isActive()) {&#10;                    sayViaWakeService(TtsSanitizer.sanitizeForTTS(nres.clarifying_question.trim()), 0);&#10;                }&#10;                stopSelf();&#10;                return;&#10;            }&#10;        }&#10;&#10;        switch (intentName) {&#10;            case &quot;FALL&quot;: {&#10;                if (!FallSignals.isActive()) {&#10;                    FallSignals.tryActivate();&#10;                    fallOwner = true;&#10;                }&#10;                sayThenListenHere(&quot;¿Estás bien?&quot;, &quot;AWAIT:0&quot;);&#10;                stopSelf(); return;&#10;            }&#10;&#10;            case &quot;QUERY_TIME&quot;: {&#10;                if (FallSignals.isActive()) { stopSelf(); return; }&#10;                Calendar c = Calendar.getInstance();&#10;                sayViaWakeService(&quot;Son las &quot; + DeviceActions.hhmm(&#10;                        c.get(Calendar.HOUR_OF_DAY), c.get(Calendar.MINUTE)) + &quot;.&quot;, 0);&#10;                stopSelf(); return;&#10;            }&#10;            case &quot;QUERY_DATE&quot;: {&#10;                if (FallSignals.isActive()) { stopSelf(); return; }&#10;                Locale esAR = new Locale(&quot;es&quot;, &quot;AR&quot;);&#10;                Calendar c = Calendar.getInstance();&#10;                SimpleDateFormat fmt = new SimpleDateFormat(&quot;EEEE, d 'de' MMMM 'de' yyyy&quot;, esAR);&#10;                String pretty = capitalizeFirst(fmt.format(c.getTime()), esAR);&#10;                sayViaWakeService(&quot;Hoy es &quot; + pretty + &quot;.&quot;, 0);&#10;                stopSelf(); return;&#10;            }&#10;            case &quot;SET_ALARM&quot;: {&#10;                if (FallSignals.isActive()) { stopSelf(); return; }&#10;                Integer hh = (nres != null &amp;&amp; nres.slots != null) ? nres.slots.hour : null;&#10;                Integer mm = (nres != null &amp;&amp; nres.slots != null) ? nres.slots.minute : null;&#10;&#10;                if ((hh == null || mm == null) &amp;&amp; nres != null &amp;&amp; nres.slots != null&#10;                        &amp;&amp; nres.slots.datetime_iso != null &amp;&amp; !nres.slots.datetime_iso.isEmpty()) {&#10;                    int[] hm = tryParseIsoToLocalHourMinute(nres.slots.datetime_iso);&#10;                    if (hm != null) { hh = hm[0]; mm = hm[1]; }&#10;                }&#10;                if (hh == null || mm == null) {&#10;                    sayViaWakeService(&quot;¿Para qué hora querés la alarma?&quot;, 0);&#10;                    stopSelf(); return;&#10;                }&#10;                // Si el backend está caído, no permitimos crear alarmas (según solicitud)&#10;                try {&#10;                    boolean backendUp = com.example.toto_app.services.BackendHealthManager.get().isBackendUp();&#10;                    if (!backendUp) {&#10;                        sayViaWakeService(&quot;No puedo configurar la alarma ahora porque no hay conexión al servidor.&quot;, 0);&#10;                        stopSelf(); return;&#10;                    }&#10;                } catch (Throwable ignored) {&#10;                    // Si no podemos consultar, ser conservadores y denegar&#10;                    sayViaWakeService(&quot;No puedo configurar la alarma ahora porque no hay conexión al servidor.&quot;, 0);&#10;                    stopSelf(); return;&#10;                }&#10;                DeviceActions.AlarmResult res = DeviceActions.setAlarm(this, hh, mm, &quot;Toto&quot;);&#10;                handleAlarmResult(res, DeviceActions.hhmm(hh, mm));&#10;                stopSelf(); return;&#10;            }&#10;&#10;            case &quot;CALL&quot;: {&#10;                if (FallSignals.isActive()) { stopSelf(); return; }&#10;                String who = (nres != null &amp;&amp; nres.slots != null) ? nres.slots.contact_query : null;&#10;                if (who == null || who.trim().isEmpty()) {&#10;                    sayViaWakeService(&quot;¿A quién querés que llame?&quot;, 0);&#10;                    stopSelf(); return;&#10;                }&#10;&#10;                boolean hasContacts = androidx.core.content.ContextCompat.checkSelfPermission(&#10;                        this, android.Manifest.permission.READ_CONTACTS)&#10;                        == android.content.pm.PackageManager.PERMISSION_GRANTED;&#10;&#10;                if (!hasContacts) {&#10;                    sayViaWakeService(&quot;Necesito permiso de contactos para llamar por nombre. Abrí la app para darlo.&quot;, 0);&#10;                    Intent perm = new Intent(this, com.example.toto_app.MainActivity.class)&#10;                            .addFlags(Intent.FLAG_ACTIVITY_NEW_TASK)&#10;                            .putExtra(&quot;request_contacts_perm&quot;, true);&#10;                    startActivity(perm);&#10;                    postWatchdog(8000);&#10;                    stopSelf(); return;&#10;                }&#10;&#10;                DeviceActions.ResolvedContact rc = DeviceActions.resolveContactByNameFuzzy(this, who);&#10;                if ((rc == null || rc.number == null || rc.number.isEmpty())&#10;                        &amp;&amp; who.startsWith(&quot;a&quot;) &amp;&amp; who.length() &gt;= 3) {&#10;                    rc = DeviceActions.resolveContactByNameFuzzy(this, who.substring(1));&#10;                }&#10;                if ((rc == null || rc.number == null || rc.number.isEmpty()) &amp;&amp; looksLikePhoneNumber(who)) {&#10;                    String dial = normalizeDialable(who);&#10;                    rc = new DeviceActions.ResolvedContact(who, dial, 1.0);&#10;                }&#10;&#10;                if (rc == null || rc.number == null || rc.number.isEmpty()) {&#10;                    NotificationService.showCallNotification(this, who, null,&#10;                            androidx.core.content.ContextCompat.checkSelfPermission(&#10;                                    this, android.Manifest.permission.CALL_PHONE)&#10;                                    == android.content.pm.PackageManager.PERMISSION_GRANTED);&#10;                    sayViaWakeService(&quot;No encontré a &quot; + who + &quot; en tus contactos. Te dejé una notificación para marcar.&quot;, 0);&#10;                    postWatchdog(8000);&#10;                    stopSelf(); return;&#10;                }&#10;&#10;                if (!AppState.isAppInForeground(this)) {&#10;                    NotificationService.showCallNotification(this, rc.name, rc.number,&#10;                            androidx.core.content.ContextCompat.checkSelfPermission(&#10;                                    this, android.Manifest.permission.CALL_PHONE)&#10;                                    == android.content.pm.PackageManager.PERMISSION_GRANTED);&#10;                    sayViaWakeService(&quot;Tocá la notificación para llamar a &quot; + rc.name + &quot;.&quot;, 0);&#10;                    postWatchdog(8000);&#10;                    stopSelf(); return;&#10;                }&#10;                if (AppState.isDeviceLocked(this)) {&#10;                    NotificationService.showCallNotification(this, rc.name, rc.number,&#10;                            androidx.core.content.ContextCompat.checkSelfPermission(&#10;                                    this, android.Manifest.permission.CALL_PHONE)&#10;                                    == android.content.pm.PackageManager.PERMISSION_GRANTED);&#10;                    sayViaWakeService(&quot;Desbloqueá y tocá la notificación para llamar a &quot; + rc.name + &quot;.&quot;, 0);&#10;                    postWatchdog(8000);&#10;                    stopSelf(); return;&#10;                }&#10;&#10;                boolean hasCall = androidx.core.content.ContextCompat.checkSelfPermission(&#10;                        this, android.Manifest.permission.CALL_PHONE)&#10;                        == android.content.pm.PackageManager.PERMISSION_GRANTED;&#10;&#10;                if (!hasCall &amp;&amp; !AppState.isDefaultDialer(this)) {&#10;                    NotificationService.showCallNotification(this, rc.name, rc.number, hasCall);&#10;                    sayViaWakeService(&quot;Tocá la notificación para llamar a &quot; + rc.name + &quot;.&quot;, 0);&#10;                    postWatchdog(8000);&#10;                    stopSelf(); return;&#10;                }&#10;&#10;                PhoneCallExecutor calls = new PhoneCallExecutor(this);&#10;                boolean ok = calls.placeDirectCall(rc.name, rc.number, AppState.isDefaultDialer(this));&#10;                if (ok) sayViaWakeService(&quot;Llamando a &quot; + rc.name + &quot;.&quot;, 0);&#10;                else {&#10;                    NotificationService.showCallNotification(this, rc.name, rc.number, hasCall);&#10;                    sayViaWakeService(&quot;No pude iniciar la llamada directa. Te dejé una notificación para marcar.&quot;, 0);&#10;                }&#10;&#10;                postWatchdog(8000);&#10;                stopSelf(); return;&#10;            }&#10;&#10;            case &quot;SEND_MESSAGE&quot;: {&#10;                if (FallSignals.isActive()) { stopSelf(); return; }&#10;                String who = (nres != null &amp;&amp; nres.slots != null) ? nres.slots.contact_query : null;&#10;                String msg = (nres != null &amp;&amp; nres.slots != null) ? nres.slots.message_text : null;&#10;&#10;                if ((who == null || who.isBlank()) || (msg == null || msg.isBlank())) {&#10;                    FallbackMessage fm = fallbackExtractMessage(transcript);&#10;                    if (who == null || who.isBlank()) who = (fm != null ? fm.who : null);&#10;                    if (msg == null || msg.isBlank()) msg = (fm != null ? fm.text : null);&#10;                }&#10;&#10;                if (who == null || who.trim().isEmpty()) {&#10;                    sayViaWakeService(&quot;¿A quién querés mandarle el mensaje?&quot;, 0);&#10;                    stopSelf(); return;&#10;                }&#10;&#10;                boolean hasContacts = androidx.core.content.ContextCompat.checkSelfPermission(&#10;                        this, android.Manifest.permission.READ_CONTACTS)&#10;                        == android.content.pm.PackageManager.PERMISSION_GRANTED;&#10;&#10;                if (!hasContacts) {&#10;                    sayViaWakeService(&quot;Necesito permiso de contactos para mandar por nombre. Abrí la app para darlo.&quot;, 0);&#10;                    Intent perm = new Intent(this, com.example.toto_app.MainActivity.class)&#10;                            .addFlags(Intent.FLAG_ACTIVITY_NEW_TASK)&#10;                            .putExtra(&quot;request_contacts_perm&quot;, true);&#10;                    startActivity(perm);&#10;                    postWatchdog(8000);&#10;                    stopSelf(); return;&#10;                }&#10;&#10;                DeviceActions.ResolvedContact rc = DeviceActions.resolveContactByNameFuzzy(this, who);&#10;                if (rc == null || rc.number == null || rc.number.isEmpty()) {&#10;                    sayViaWakeService(&quot;No encontré a &quot; + who + &quot; en tus contactos.&quot;, 0);&#10;                    stopSelf(); return;&#10;                }&#10;&#10;                if (msg == null || msg.trim().isEmpty()) {&#10;                    sayViaWakeService(&quot;¿Qué querés que le diga a &quot; + rc.name + &quot;?&quot;, 0);&#10;                    stopSelf(); return;&#10;                }&#10;&#10;                String to = rc.number.replaceAll(&quot;[^0-9+]&quot;, &quot;&quot;);&#10;                try {&#10;                    com.example.toto_app.network.WhatsAppSendRequest wreq =&#10;                            new com.example.toto_app.network.WhatsAppSendRequest(to, msg.trim(), Boolean.FALSE);&#10;                    retrofit2.Response&lt;com.example.toto_app.network.WhatsAppSendResponse&gt; wresp =&#10;                            RetrofitClient.api().waSend(wreq).execute();&#10;&#10;                    com.example.toto_app.network.WhatsAppSendResponse wbody = wresp.body();&#10;                    boolean ok =&#10;                            wresp.isSuccessful()&#10;                                    &amp;&amp; wbody != null&#10;                                    &amp;&amp; (&quot;ok&quot;.equalsIgnoreCase(wbody.status)&#10;                                    || &quot;ok_template&quot;.equalsIgnoreCase(wbody.status)&#10;                                    || (wbody.id != null &amp;&amp; !wbody.id.trim().isEmpty()));&#10;&#10;                    if (ok) sayViaWakeService(&quot;Listo, le mandé el mensaje a &quot; + rc.name + &quot;.&quot;, 0);&#10;                    else {&#10;                        String err = null;&#10;                        try { err = (wresp.errorBody() != null) ? wresp.errorBody().string() : null; } catch (Exception ignored) {}&#10;                        Log.e(TAG, &quot;WA send failed: HTTP=&quot; + (wresp != null ? wresp.code() : -1)&#10;                                + &quot; status=&quot; + (wbody != null ? wbody.status : &quot;null&quot;)&#10;                                + &quot; id=&quot; + (wbody != null ? wbody.id : &quot;null&quot;)&#10;                                + &quot; err=&quot; + err);&#10;                        if (err != null &amp;&amp; (err.contains(&quot;recipient_not_allowed&quot;) || err.contains(&quot;131030&quot;)))&#10;                            sayViaWakeService(&quot;No pude enviar por WhatsApp porque ese número no está autorizado aún.&quot;, 0);&#10;                        else&#10;                            sayViaWakeService(&quot;No pude mandar el mensaje ahora.&quot;, 0);&#10;                    }&#10;                } catch (Exception ex) {&#10;                    Log.e(TAG, &quot;Error /api/whatsapp/send&quot;, ex);&#10;                    sayViaWakeService(&quot;Tuve un problema mandando el mensaje.&quot;, 0);&#10;                }&#10;&#10;                stopSelf(); return;&#10;            }&#10;&#10;            case &quot;SPOTIFY_PLAY&quot;: {&#10;                if (FallSignals.isActive()) { stopSelf(); return; }&#10;                String query = (nres != null &amp;&amp; nres.slots != null) ? nres.slots.message_text : null;&#10;                if (query == null || query.isBlank()) {&#10;                    sayViaWakeService(&quot;¿Qué querés escuchar en Spotify?&quot;, 0);&#10;                    stopSelf(); return;&#10;                }&#10;&#10;                try {&#10;                    retrofit2.Response&lt;SpotifyStatus&gt; s = RetrofitClient.api().spotifyStatus().execute();&#10;                    SpotifyStatus st = s.isSuccessful() ? s.body() : null;&#10;                    if (st == null) { sayViaWakeService(&quot;No pude verificar Spotify ahora.&quot;, 0); stopSelf(); return; }&#10;&#10;                    if (!Boolean.TRUE.equals(st.connected)) {&#10;                        String url = st.loginUrl;&#10;                        Intent i = new Intent(Intent.ACTION_VIEW, android.net.Uri.parse(url));&#10;                        i.addFlags(Intent.FLAG_ACTIVITY_NEW_TASK);&#10;                        android.app.PendingIntent pi = android.app.PendingIntent.getActivity(&#10;                                this, 1001, i,&#10;                                android.app.PendingIntent.FLAG_UPDATE_CURRENT | android.app.PendingIntent.FLAG_IMMUTABLE);&#10;                        NotificationService.simpleActionNotification(this, &quot;Conectar Spotify&quot;,&#10;                                &quot;Tocá para vincular tu cuenta de Spotify.&quot;, pi);&#10;                        sayViaWakeService(&quot;Necesito conectar tu Spotify. Tocá la notificación para autorizar.&quot;, 0);&#10;                        postWatchdog(8000); stopSelf(); return;&#10;                    }&#10;&#10;                    if (st.premium != null &amp;&amp; !st.premium) {&#10;                        sayViaWakeService(&quot;Tu cuenta de Spotify no es Premium.&quot;, 0);&#10;                        stopSelf(); return;&#10;                    }&#10;&#10;                    if (st.deviceCount == null || st.deviceCount == 0) {&#10;                        boolean activated = ensureSpotifyDeviceActivated(query, /*timeoutMs=*/8000);&#10;                        if (!activated) {&#10;                            sayViaWakeService(&quot;No encuentro un dispositivo de Spotify. Abrí Spotify una vez y volvemos a intentar.&quot;, 0);&#10;                            stopSelf(); return;&#10;                        }&#10;                    }&#10;&#10;                    java.util.Map&lt;String,String&gt; body = new java.util.HashMap&lt;&gt;();&#10;                    body.put(&quot;query&quot;, query);&#10;                    if (st.suggestedDeviceId != null &amp;&amp; !st.suggestedDeviceId.isEmpty()) {&#10;                        body.put(&quot;deviceId&quot;, st.suggestedDeviceId);&#10;                    }&#10;&#10;                    retrofit2.Response&lt;com.google.gson.JsonObject&gt; r = RetrofitClient.api().spotifyPlay(body).execute();&#10;                    if (r.isSuccessful()) {&#10;                        signalCmdFinishedNow();&#10;                        signalCmdFinishedLater(1500);&#10;                    } else {&#10;                        String err = null;&#10;                        try { err = (r.errorBody() != null) ? r.errorBody().string() : null; } catch (Exception ignore) {}&#10;                        String speak = &quot;No pude reproducir en Spotify ahora.&quot;;&#10;                        if (err != null) {&#10;                            if (err.contains(&quot;NOT_LOGGED_IN&quot;)) speak = &quot;Necesitás conectar tu Spotify.&quot;;&#10;                            else if (err.contains(&quot;PREMIUM_REQUIRED&quot;)) speak = &quot;Tu cuenta de Spotify no es Premium.&quot;;&#10;                            else if (err.contains(&quot;NO_DEVICE&quot;)) speak = &quot;No hay un dispositivo de Spotify activo.&quot;;&#10;                            else if (err.contains(&quot;SEARCH_EMPTY&quot;)) speak = &quot;No encontré ese tema en Spotify.&quot;;&#10;                        }&#10;                        sayViaWakeService(speak, 0);&#10;                    }&#10;&#10;                } catch (Exception ex) {&#10;                    Log.e(TAG, &quot;Spotify play error&quot;, ex);&#10;                    sayViaWakeService(&quot;Tuve un problema con Spotify.&quot;, 0);&#10;                }&#10;&#10;                stopSelf(); return;&#10;            }&#10;&#10;            case &quot;SPOTIFY_PAUSE&quot;: {&#10;                if (FallSignals.isActive()) { stopSelf(); return; }&#10;                try {&#10;                    retrofit2.Response&lt;SpotifyResponse&gt; r = RetrofitClient.api().spotifyPause().execute();&#10;                    if (r.code() == 401 || r.code() == 403) {&#10;                        sayViaWakeService(&quot;Necesitás vincular tu cuenta de Spotify en la app.&quot;, 0);&#10;                    } else if (!isOk(r)) {&#10;                        sayViaWakeService(&quot;No pude pausar Spotify.&quot;, 0);&#10;                    }&#10;                } catch (Exception ex) {&#10;                    Log.e(TAG, &quot;Error /api/spotify/pause&quot;, ex);&#10;                    sayViaWakeService(&quot;Tuve un problema con Spotify.&quot;, 0);&#10;                }&#10;                stopSelf(); return;&#10;            }&#10;&#10;            case &quot;SPOTIFY_RESUME&quot;: {&#10;                if (FallSignals.isActive()) { stopSelf(); return; }&#10;                sayViaWakeService(&quot;No pude continuar la reproducción.&quot;, 0);&#10;                stopSelf(); return;&#10;            }&#10;&#10;            case &quot;SPOTIFY_NEXT&quot;: {&#10;                if (FallSignals.isActive()) { stopSelf(); return; }&#10;                try {&#10;                    retrofit2.Response&lt;SpotifyResponse&gt; r = RetrofitClient.api().spotifyNext().execute();&#10;                    if (r.code() == 401 || r.code() == 403) {&#10;                        sayViaWakeService(&quot;Necesitás vincular tu cuenta de Spotify en la app.&quot;, 0);&#10;                    } else if (!isOk(r)) {&#10;                        sayViaWakeService(&quot;No pude pasar al siguiente.&quot;, 0);&#10;                    }&#10;                } catch (Exception ex) {&#10;                    Log.e(TAG, &quot;Error /api/spotify/next&quot;, ex);&#10;                    sayViaWakeService(&quot;Tuve un problema con Spotify.&quot;, 0);&#10;                }&#10;                stopSelf(); return;&#10;            }&#10;&#10;            case &quot;SPOTIFY_PREV&quot;: {&#10;                if (FallSignals.isActive()) { stopSelf(); return; }&#10;                try {&#10;                    retrofit2.Response&lt;SpotifyResponse&gt; r = RetrofitClient.api().spotifyPrev().execute();&#10;                    if (r.code() == 401 || r.code() == 403) {&#10;                        sayViaWakeService(&quot;Necesitás vincular tu cuenta de Spotify en la app.&quot;, 0);&#10;                    } else if (!isOk(r)) {&#10;                        sayViaWakeService(&quot;No pude volver al anterior.&quot;, 0);&#10;                    }&#10;                } catch (Exception ex) {&#10;                    Log.e(TAG, &quot;Error /api/spotify/prev&quot;, ex);&#10;                    sayViaWakeService(&quot;Tuve un problema con Spotify.&quot;, 0);&#10;                }&#10;                stopSelf(); return;&#10;            }&#10;&#10;            case &quot;SPOTIFY_SET_VOLUME&quot;: {&#10;                if (FallSignals.isActive()) { stopSelf(); return; }&#10;                String v = (nres != null &amp;&amp; nres.slots != null) ? nres.slots.message_text : null;&#10;                if (v == null || v.trim().isEmpty()) v = &quot;up&quot;;&#10;                try {&#10;                    retrofit2.Response&lt;SpotifyResponse&gt; r =&#10;                            RetrofitClient.api().spotifyVolume(new SpotifyVolumeRequest(v.trim())).execute();&#10;                    if (r.code() == 401 || r.code() == 403) {&#10;                        sayViaWakeService(&quot;Necesitás vincular tu cuenta de Spotify en la app.&quot;, 0);&#10;                    } else if (!isOk(r)) {&#10;                        sayViaWakeService(&quot;No pude ajustar el volumen en Spotify.&quot;, 0);&#10;                    }&#10;                } catch (Exception ex) {&#10;                    Log.e(TAG, &quot;Error /api/spotify/volume&quot;, ex);&#10;                    sayViaWakeService(&quot;Tuve un problema con Spotify.&quot;, 0);&#10;                }&#10;                stopSelf(); return;&#10;            }&#10;&#10;            case &quot;SPOTIFY_SET_SHUFFLE&quot;: {&#10;                if (FallSignals.isActive()) { stopSelf(); return; }&#10;                String state = (nres != null &amp;&amp; nres.slots != null) ? nres.slots.message_text : null;&#10;                if (state == null || state.isBlank()) state = &quot;on&quot;;&#10;                try {&#10;                    retrofit2.Response&lt;SpotifyResponse&gt; r =&#10;                            RetrofitClient.api().spotifyShuffle(new SpotifyShuffleRequest(state)).execute();&#10;                    if (r.code() == 401 || r.code() == 403) {&#10;                        sayViaWakeService(&quot;Necesitás vincular tu cuenta de Spotify en la app.&quot;, 0);&#10;                    } else if (!isOk(r)) {&#10;                        sayViaWakeService(&quot;No pude cambiar el modo aleatorio.&quot;, 0);&#10;                    }&#10;                } catch (Exception ex) {&#10;                    Log.e(TAG, &quot;Error /api/spotify/shuffle&quot;, ex);&#10;                    sayViaWakeService(&quot;Tuve un problema con Spotify.&quot;, 0);&#10;                }&#10;                stopSelf(); return;&#10;            }&#10;&#10;            case &quot;SPOTIFY_SET_REPEAT&quot;: {&#10;                if (FallSignals.isActive()) { stopSelf(); return; }&#10;                String state = (nres != null &amp;&amp; nres.slots != null) ? nres.slots.message_text : null;&#10;                if (state == null || state.isBlank()) state = &quot;track&quot;;&#10;                try {&#10;                    retrofit2.Response&lt;SpotifyResponse&gt; r =&#10;                            RetrofitClient.api().spotifyRepeat(new SpotifyRepeatRequest(state)).execute();&#10;                    if (r.code() == 401 || r.code() == 403) {&#10;                        sayViaWakeService(&quot;Necesitás vincular tu cuenta de Spotify en la app.&quot;, 0);&#10;                    } else if (!isOk(r)) {&#10;                        sayViaWakeService(&quot;No pude cambiar el modo de repetición.&quot;, 0);&#10;                    }&#10;                } catch (Exception ex) {&#10;                    Log.e(TAG, &quot;Error /api/spotify/repeat&quot;, ex);&#10;                    sayViaWakeService(&quot;Tuve un problema con Spotify.&quot;, 0);&#10;                }&#10;                stopSelf(); return;&#10;            }&#10;&#10;            case &quot;CANCEL&quot;: {&#10;                if (FallSignals.isActive()) { stopSelf(); return; }&#10;                sayViaWakeService(&quot;Listo.&quot;, 0);&#10;                stopSelf(); return;&#10;            }&#10;            case &quot;ANSWER&quot;:&#10;            case &quot;UNKNOWN&quot;:&#10;            default: {&#10;                if (FallSignals.isActive()) { stopSelf(); return; }&#10;                boolean backendUp = true;&#10;                try { backendUp = com.example.toto_app.services.BackendHealthManager.get().isBackendUp(); } catch (Throwable ignore) { backendUp = true; }&#10;                if (!backendUp) {&#10;                    // Cuando el backend está caído, evitamos decir &quot;No estoy seguro&quot; y ofrecemos intentar localmente&#10;                    String offlineReply = &quot;No hay conexión al servidor. Puedo intentar ejecutar algunas acciones locales como configurar alarmas, iniciar llamadas o detectar caídas.&quot;;&#10;                    sayViaWakeService(TtsSanitizer.sanitizeForTTS(offlineReply), 0);&#10;                    stopSelf(); return;&#10;                }&#10;                try {&#10;                    AskRequest rq = new AskRequest();&#10;                    rq.prompt = transcript;&#10;                    Response&lt;AskResponse&gt; r2 = RetrofitClient.api().ask(rq).execute();&#10;                    String reply = (r2.isSuccessful() &amp;&amp; r2.body() != null &amp;&amp; r2.body().reply != null)&#10;                            ? r2.body().reply.trim()&#10;                            : &quot;No estoy seguro, ¿podés repetir?&quot;;&#10;                    sayViaWakeService(TtsSanitizer.sanitizeForTTS(reply), 0);&#10;                } catch (Exception ex) {&#10;                    Log.e(TAG, &quot;Error /api/ask&quot;, ex);&#10;                    sayViaWakeService(&quot;Tuve un problema procesando eso.&quot;, 0);&#10;                }&#10;                stopSelf(); return;&#10;            }&#10;        }&#10;    }&#10;&#10;    private void sayThenListenHere(String text, @Nullable String nextFallMode) {&#10;        Intent say = new Intent(this, WakeWordService.class)&#10;                .setAction(WakeWordService.ACTION_SAY)&#10;                .putExtra(&quot;text&quot;, TtsSanitizer.sanitizeForTTS(text))&#10;                .putExtra(WakeWordService.EXTRA_AFTER_SAY_START_SERVICE, true)&#10;                .putExtra(WakeWordService.EXTRA_AFTER_SAY_USER_NAME, userName);&#10;        if (nextFallMode != null) {&#10;            say.putExtra(WakeWordService.EXTRA_AFTER_SAY_FALL_MODE, nextFallMode);&#10;        }&#10;        androidx.core.content.ContextCompat.startForegroundService(this, say);&#10;    }&#10;&#10;    private void handleAlarmResult(DeviceActions.AlarmResult res, String when) {&#10;        switch (res) {&#10;            case SET_SILENT:&#10;                sayViaWakeService(&quot;Listo, te pongo una alarma para las &quot; + when + &quot;.&quot;, 0);&#10;                break;&#10;            case UI_ACTION_REQUIRED:&#10;                sayViaWakeService(&quot;Te dejé una notificación para confirmar la alarma de las &quot; + when + &quot;.&quot;, 0);&#10;                break;&#10;            default:&#10;                sayViaWakeService(&quot;No pude crear la alarma. Fijate permisos del reloj.&quot;, 0);&#10;                break;&#10;        }&#10;    }&#10;&#10;    private void sayViaWakeService(String text, int watchdogMs) {&#10;        Intent say = new Intent(this, WakeWordService.class)&#10;                .setAction(WakeWordService.ACTION_SAY)&#10;                .putExtra(&quot;text&quot;, text);&#10;        androidx.core.content.ContextCompat.startForegroundService(this, say);&#10;        if (watchdogMs &gt; 0) postWatchdog(watchdogMs);&#10;    }&#10;&#10;    private void postWatchdog(int ms) {&#10;        new android.os.Handler(getMainLooper()).postDelayed(() -&gt;&#10;                sendBroadcast(new Intent(WakeWordService.ACTION_CMD_FINISHED)), ms);&#10;    }&#10;&#10;    private void signalCmdFinishedNow() {&#10;        Intent svc = new Intent(this, WakeWordService.class)&#10;                .setAction(WakeWordService.ACTION_CMD_FINISHED)&#10;                .putExtra(&quot;reason&quot;, &quot;SPOTIFY_PLAY_OK&quot;);&#10;        androidx.core.content.ContextCompat.startForegroundService(this, svc);&#10;&#10;        sendBroadcast(new Intent(WakeWordService.ACTION_CMD_FINISHED)&#10;                .putExtra(&quot;reason&quot;, &quot;SPOTIFY_PLAY_OK&quot;));&#10;    }&#10;&#10;    private void signalCmdFinishedLater(int delayMs) {&#10;        new android.os.Handler(getMainLooper()).postDelayed(() -&gt; {&#10;            Intent svc = new Intent(this, WakeWordService.class)&#10;                    .setAction(WakeWordService.ACTION_CMD_FINISHED)&#10;                    .putExtra(&quot;reason&quot;, &quot;SPOTIFY_PLAY_OK_DELAYED&quot;);&#10;            androidx.core.content.ContextCompat.startForegroundService(this, svc);&#10;&#10;            sendBroadcast(new Intent(WakeWordService.ACTION_CMD_FINISHED)&#10;                    .putExtra(&quot;reason&quot;, &quot;SPOTIFY_PLAY_OK_DELAYED&quot;));&#10;        }, Math.max(150, delayMs));&#10;    }&#10;&#10;    @Nullable @Override public IBinder onBind(Intent intent) { return null; }&#10;    @Override public void onDestroy() { super.onDestroy(); }&#10;&#10;    @Nullable&#10;    private static int[] tryParseIsoToLocalHourMinute(String iso) {&#10;        if (iso == null || iso.isEmpty()) return null;&#10;        String[] patterns = new String[] {&#10;                &quot;yyyy-MM-dd'T'HH:mm:ss.SSSXXX&quot;,&#10;                &quot;yyyy-MM-dd'T'HH:mm:ssXXX&quot;,&#10;                &quot;yyyy-MM-dd'T'HH:mmXXX&quot;,&#10;                &quot;yyyy-MM-dd'T'HH:mm:ss'Z'&quot;,&#10;                &quot;yyyy-MM-dd'T'HH:mm'Z'&quot;,&#10;                &quot;yyyy-MM-dd'T'HH:mm:ss&quot;,&#10;                &quot;yyyy-MM-dd'T'HH:mm&quot;&#10;        };&#10;        for (String p : patterns) {&#10;            try {&#10;                SimpleDateFormat sdf = new SimpleDateFormat(p, Locale.US);&#10;                if (!p.endsWith(&quot;XXX&quot;)) {&#10;                    sdf.setTimeZone(TimeZone.getTimeZone(&quot;UTC&quot;));&#10;                }&#10;                Date d = sdf.parse(iso);&#10;                if (d != null) {&#10;                    Calendar cal = Calendar.getInstance();&#10;                    cal.setTime(d);&#10;                    return new int[]{ cal.get(Calendar.HOUR_OF_DAY), cal.get(Calendar.MINUTE) };&#10;                }&#10;            } catch (ParseException ignored) { }&#10;        }&#10;        return null;&#10;    }&#10;&#10;    private static String capitalizeFirst(String s, Locale loc) {&#10;        if (s == null || s.isEmpty()) return s;&#10;        return s.substring(0, 1).toUpperCase(loc) + s.substring(1);&#10;    }&#10;&#10;    private static String safe(String s) { return (s == null) ? &quot;null&quot; : s; }&#10;&#10;    private static String slotsToString(NluRouteResponse.Slots s) {&#10;        if (s == null) return &quot;{}&quot;;&#10;        return &quot;{contact=&quot; + safe(s.contact_query) +&#10;                &quot;, hour=&quot; + s.hour +&#10;                &quot;, minute=&quot; + s.minute +&#10;                &quot;, dt=&quot; + safe(s.datetime_iso) +&#10;                &quot;, msg=&quot; + safe(s.message_text) +&#10;                &quot;, app=&quot; + safe(s.app_name) + &quot;}&quot;;&#10;    }&#10;&#10;    private static boolean looksLikePhoneNumber(String s) {&#10;        if (s == null) return false;&#10;        String t = s.replaceAll(&quot;[^0-9+]&quot;, &quot;&quot;);&#10;        return t.length() &gt;= 6;&#10;    }&#10;&#10;    private static String normalizeDialable(String s) {&#10;        if (s == null) return &quot;&quot;;&#10;        return s.replaceAll(&quot;[^0-9+]&quot;, &quot;&quot;);&#10;    }&#10;&#10;    private static final class FallbackMessage {&#10;        final String who; final String text;&#10;        FallbackMessage(String who, String text) { this.who = who; this.text = text; }&#10;    }&#10;&#10;    @Nullable&#10;    private static FallbackMessage fallbackExtractMessage(String raw) {&#10;        if (raw == null) return null;&#10;        String s = java.text.Normalizer.normalize(raw, java.text.Normalizer.Form.NFD)&#10;                .replaceAll(&quot;\\p{M}&quot;, &quot;&quot;)&#10;                .toLowerCase(java.util.Locale.ROOT)&#10;                .replaceAll(&quot;[“”\&quot;']&quot;, &quot;&quot;)&#10;                .replaceAll(&quot;\\s+&quot;, &quot; &quot;)&#10;                .trim();&#10;&#10;        String[] pats = new String[] {&#10;                &quot;\\b(?:mandale|manda|mandar|escribile|escribe|escribir|decile|decime|dile|avisale|avisa|avisar)(?:\\s+un\\s+mensaje)?\\s+a\\s+([a-z0-9ñáéíóúü\\s.-]{1,40})\\s*(?:que|de que|diciendole|diciendole que|:|–|-)\\s*(.+)$&quot;,&#10;                &quot;\\b(?:mandale|manda|escribile|decile|avisale)(?:\\s+por\\s+whatsapp)?\\s+a\\s+([a-z0-9ñáéíóúü\\s.-]{1,40})\\s+(.*)$&quot;,&#10;                &quot;\\b(?:mensaje|msj)\\s+a\\s+([a-z0-9ñáéíóúü\\s.-]{1,40})\\s*(?:que|:)?\\s*(.+)$&quot;&#10;        };&#10;&#10;        for (String p : pats) {&#10;            java.util.regex.Matcher m = java.util.regex.Pattern.compile(p).matcher(s);&#10;            if (m.find()) {&#10;                String who = cleanPerson(m.group(1));&#10;                String text = cleanMessage(m.groupCount() &gt;= 2 ? m.group(2) : &quot;&quot;);&#10;                if (!who.isEmpty() &amp;&amp; !text.isEmpty()) return new FallbackMessage(who, text);&#10;            }&#10;        }&#10;&#10;        java.util.regex.Matcher m2 = java.util.regex.Pattern&#10;                .compile(&quot;\\b(?:mandale|manda|escribile|decile|dile|avisale)\\s+a\\s+([a-z0-9ñáéíóúü\\s.-]{1,40})\\b&quot;)&#10;                .matcher(s);&#10;        if (m2.find()) {&#10;            String who = cleanPerson(m2.group(1));&#10;            if (!who.isEmpty()) return new FallbackMessage(who, &quot;&quot;);&#10;        }&#10;        return null;&#10;    }&#10;&#10;    private static String cleanPerson(String s) {&#10;        if (s == null) return &quot;&quot;;&#10;        s = s.replaceAll(&quot;(?:\\s+por\\s+favor.*$)|(?:\\s+gracias.*$)|(?:\\s+ahora.*$)|(?:\\s+urgente.*$)|(?:\\s+ya.*$)&quot;, &quot; &quot;);&#10;        s = s.replaceAll(&quot;[^a-z0-9ñáéíóúü\\s.-]&quot;, &quot; &quot;);&#10;        s = s.replaceAll(&quot;\\s+&quot;, &quot; &quot;).trim();&#10;        if (s.startsWith(&quot;a&quot;) &amp;&amp; s.length() &gt;= 2 &amp;&amp; &quot;bcdfghjklmnñpqrstvwxyz&quot;.indexOf(s.charAt(1)) &gt;= 0) {&#10;            s = s.substring(1);&#10;        }&#10;        String[] tok = s.split(&quot;\\s+&quot;);&#10;        int limit = Math.min(tok.length, 4);&#10;        StringBuilder out = new StringBuilder();&#10;        for (int i = 0; i &lt; limit; i++) { if (i &gt; 0) out.append(' '); out.append(tok[i]); }&#10;        return out.toString();&#10;    }&#10;&#10;    private static String cleanMessage(String s) {&#10;        if (s == null) return &quot;&quot;;&#10;        s = s.replaceAll(&quot;\\s+&quot;, &quot; &quot;).trim();&#10;        s = s.replaceAll(&quot;(\\s+por\\s+favor.*$)|(\\s+gracias.*$)&quot;, &quot;&quot;).trim();&#10;        return s;&#10;    }&#10;&#10;    private static boolean isOk(retrofit2.Response&lt;SpotifyResponse&gt; r) {&#10;        if (r == null) return false;&#10;        if (!r.isSuccessful()) return false;&#10;        SpotifyResponse b = r.body();&#10;        if (b == null) return true;&#10;        if (b.ok != null) return b.ok;&#10;        if (b.status != null) return &quot;ok&quot;.equalsIgnoreCase(b.status) || &quot;success&quot;.equalsIgnoreCase(b.status);&#10;        return true;&#10;    }&#10;&#10;    private boolean tryOpenSpotifyNow(String query) {&#10;        try {&#10;            Intent open = new Intent(Intent.ACTION_VIEW,&#10;                    android.net.Uri.parse(&quot;spotify:search:&quot; + android.net.Uri.encode(query)));&#10;            open.addFlags(Intent.FLAG_ACTIVITY_NEW_TASK);&#10;            startActivity(open);&#10;            return true;&#10;        } catch (Exception e) {&#10;            Log.w(TAG, &quot;No pude abrir Spotify con URI (cae a abrir paquete): &quot; + e.getMessage());&#10;            try {&#10;                Intent fallback = getPackageManager().getLaunchIntentForPackage(&quot;com.spotify.music&quot;);&#10;                if (fallback != null) {&#10;                    fallback.addFlags(Intent.FLAG_ACTIVITY_NEW_TASK);&#10;                    startActivity(fallback);&#10;                    return true;&#10;                }&#10;            } catch (Exception e2) {&#10;                Log.e(TAG, &quot;No pude abrir Spotify app: &quot;, e2);&#10;            }&#10;        }&#10;        return false;&#10;    }&#10;&#10;    private boolean ensureSpotifyDeviceActivated(String query, int timeoutMs) {&#10;        long deadline = SystemClock.uptimeMillis() + Math.max(2000, timeoutMs);&#10;&#10;        boolean canLaunchNow = AppState.isAppInForeground(this) &amp;&amp; !AppState.isDeviceLocked(this);&#10;        if (canLaunchNow) {&#10;            tryOpenSpotifyNow(query);&#10;        } else {&#10;            Intent open = getPackageManager().getLaunchIntentForPackage(&quot;com.spotify.music&quot;);&#10;            if (open != null) {&#10;                open.addFlags(Intent.FLAG_ACTIVITY_NEW_TASK);&#10;                android.app.PendingIntent pi = android.app.PendingIntent.getActivity(&#10;                        this, 1002, open,&#10;                        android.app.PendingIntent.FLAG_UPDATE_CURRENT | android.app.PendingIntent.FLAG_IMMUTABLE);&#10;                NotificationService.simpleActionNotification(&#10;                        this, &quot;Abrir Spotify&quot;, &quot;Tocá para activar un dispositivo.&quot;, pi);&#10;            }&#10;        }&#10;&#10;        while (SystemClock.uptimeMillis() &lt; deadline) {&#10;            try {&#10;                retrofit2.Response&lt;SpotifyStatus&gt; s = RetrofitClient.api().spotifyStatus().execute();&#10;                SpotifyStatus st = s.isSuccessful() ? s.body() : null;&#10;                if (st != null &amp;&amp; Boolean.TRUE.equals(st.connected)) {&#10;                    Integer dc = st.deviceCount;&#10;                    if (dc != null &amp;&amp; dc &gt; 0) return true;&#10;                }&#10;            } catch (Exception e) {&#10;                Log.w(TAG, &quot;Polling spotifyStatus: &quot; + e.getMessage());&#10;            }&#10;            try { Thread.sleep(800); } catch (InterruptedException ignored) {}&#10;        }&#10;        return false;&#10;    }&#10;}&#10;" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/app/src/main/java/com/example/toto_app/services/WakeWordService.java">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/app/src/main/java/com/example/toto_app/services/WakeWordService.java" />
              <option name="originalContent" value="package com.example.toto_app.services;&#10;&#10;import android.app.Notification;&#10;import android.app.NotificationChannel;&#10;import android.app.NotificationManager;&#10;import android.app.Service;&#10;import android.content.BroadcastReceiver;&#10;import android.content.Context;&#10;import android.content.Intent;&#10;import android.content.IntentFilter;&#10;import android.media.AudioAttributes;&#10;import android.media.AudioFocusRequest;&#10;import android.media.AudioManager;&#10;import android.os.Build;&#10;import android.os.Bundle;&#10;import android.os.IBinder;&#10;import android.os.PowerManager;&#10;import android.os.SystemClock;&#10;import android.speech.tts.TextToSpeech;&#10;import android.speech.tts.UtteranceProgressListener;&#10;import android.util.Log;&#10;import android.widget.Toast;&#10;&#10;import androidx.annotation.Nullable;&#10;import androidx.core.app.NotificationCompat;&#10;&#10;import org.json.JSONObject;&#10;import org.vosk.LibVosk;&#10;import org.vosk.LogLevel;&#10;import org.vosk.Model;&#10;import org.vosk.Recognizer;&#10;import org.vosk.android.RecognitionListener;&#10;import org.vosk.android.SpeechService;&#10;import org.vosk.android.StorageService;&#10;&#10;import java.io.IOException;&#10;import java.util.Locale;&#10;import java.util.Random;&#10;import java.util.regex.Pattern;&#10;&#10;import com.example.toto_app.falls.FallSignals;&#10;import com.example.toto_app.util.TtsSanitizer;&#10;&#10;public class WakeWordService extends Service implements RecognitionListener {&#10;&#10;    public static final String ACTION_CMD_FINISHED  = &quot;com.example.toto_app.ACTION_CMD_FINISHED&quot;;&#10;    public static final String ACTION_SAY           = &quot;com.example.toto_app.ACTION_SAY&quot;;&#10;&#10;    public static final String ACTION_PAUSE_LISTEN  = &quot;com.example.toto_app.ACTION_PAUSE_LISTEN&quot;;&#10;    public static final String ACTION_RESUME_LISTEN = &quot;com.example.toto_app.ACTION_RESUME_LISTEN&quot;;&#10;&#10;    public static final String ACTION_STOP_TTS      = &quot;com.example.toto_app.ACTION_STOP_TTS&quot;;&#10;&#10;    public static final String EXTRA_AFTER_SAY_START_SERVICE = &quot;after_say_start_service&quot;;&#10;    public static final String EXTRA_AFTER_SAY_USER_NAME     = &quot;after_say_user_name&quot;;&#10;    public static final String EXTRA_AFTER_SAY_FALL_MODE     = &quot;after_say_fall_mode&quot;;&#10;&#10;    public static final String EXTRA_REASON         = &quot;reason&quot;;&#10;    public static final String REASON_FALL_CLEAR    = &quot;FALL_CLEAR&quot;;&#10;&#10;    @Nullable private Intent pendingAfterSay;&#10;&#10;    private static final String TAG = &quot;WakeWord&quot;;&#10;    private static final String CHANNEL_ID = &quot;toto_listening&quot;;&#10;&#10;    private static final long MIN_COOLDOWN_MS   = 1500;&#10;    private static final long DEDUPE_WINDOW_MS  = 2500;&#10;&#10;    private long   lastTriggerAt     = 0L;&#10;    private long   lastDetectionAt   = 0L;&#10;    private String lastDetectionText = &quot;&quot;;&#10;    private volatile boolean triggered = false;&#10;&#10;    private String userName = &quot;Juan&quot;;&#10;&#10;    private Model model;&#10;    private SpeechService speechService;&#10;&#10;    private TextToSpeech tts;&#10;    private volatile boolean ttsReady = false;&#10;    private final Random rng = new Random();&#10;&#10;    private volatile boolean isSpeaking = false;&#10;&#10;    private PowerManager.WakeLock wakeLock;&#10;    @Nullable private AudioFocusRequest audioFocusRequest;&#10;&#10;    // Estado de pausa de escucha&#10;    private volatile boolean listeningPaused = false;&#10;&#10;    // “tipo” de lo que se está diciendo ahora (&quot;ACK&quot; o &quot;SAY&quot;)&#10;    @Nullable private String currentUtteranceKind = null;&#10;&#10;    private volatile long blockWakeUntilMs = 0L;&#10;&#10;    private static final String[] ACK_TEMPLATES = new String[] {&#10;            &quot;¿En qué te puedo ayudar, %s?&quot;,&#10;            &quot;Sí, %s, decime.&quot;,&#10;            &quot;Te escucho, %s.&quot;,&#10;            &quot;%s, decime.&quot;,&#10;            &quot;¿Qué necesitás, %s?&quot;,&#10;            &quot;Acá estoy, %s.&quot;&#10;    };&#10;&#10;    private void acquireWakeLock() {&#10;        if (wakeLock == null) {&#10;            PowerManager pm = (PowerManager) getSystemService(POWER_SERVICE);&#10;            if (pm != null) {&#10;                wakeLock = pm.newWakeLock(PowerManager.PARTIAL_WAKE_LOCK, TAG + &quot;:MicLock&quot;);&#10;                wakeLock.setReferenceCounted(false);&#10;            }&#10;        }&#10;        if (wakeLock != null &amp;&amp; !wakeLock.isHeld()) {&#10;            wakeLock.acquire(10 * 60 * 1000L);&#10;        }&#10;    }&#10;&#10;    private void releaseWakeLock() {&#10;        if (wakeLock != null &amp;&amp; wakeLock.isHeld()) {&#10;            try { wakeLock.release(); } catch (Exception ignored) {}&#10;        }&#10;    }&#10;&#10;    private final BroadcastReceiver cmdFinishedReceiver = new BroadcastReceiver() {&#10;        @Override public void onReceive(Context context, Intent intent) {&#10;            Log.d(TAG, &quot;ACTION_CMD_FINISHED (broadcast) → rearmar wake&quot;);&#10;            rearmWake();&#10;        }&#10;    };&#10;&#10;    private final BroadcastReceiver fallReceiver = new BroadcastReceiver() {&#10;        @Override public void onReceive(Context context, Intent intent) {&#10;            String src = intent.getStringExtra(FallSignals.EXTRA_SOURCE);&#10;            String un  = intent.getStringExtra(FallSignals.EXTRA_USER_NAME);&#10;&#10;            if (!FallSignals.tryActivate()) return;&#10;&#10;            Intent stopTts = new Intent(WakeWordService.this, WakeWordService.class).setAction(ACTION_STOP_TTS);&#10;            androidx.core.content.ContextCompat.startForegroundService(WakeWordService.this, stopTts);&#10;&#10;            Intent pause = new Intent(WakeWordService.this, WakeWordService.class).setAction(ACTION_PAUSE_LISTEN);&#10;            androidx.core.content.ContextCompat.startForegroundService(WakeWordService.this, pause);&#10;&#10;            String who = (un == null || un.trim().isEmpty()) ? userName : un.trim();&#10;            Intent say = new Intent(WakeWordService.this, WakeWordService.class)&#10;                    .setAction(ACTION_SAY)&#10;                    .putExtra(&quot;text&quot;, &quot;Escuché un golpe. ¿Estás bien?&quot;)&#10;                    .putExtra(EXTRA_AFTER_SAY_START_SERVICE, true)&#10;                    .putExtra(EXTRA_AFTER_SAY_USER_NAME, who)&#10;                    .putExtra(EXTRA_AFTER_SAY_FALL_MODE, &quot;AWAIT:0&quot;);&#10;            androidx.core.content.ContextCompat.startForegroundService(WakeWordService.this, say);&#10;        }&#10;    };&#10;&#10;    @Override&#10;    public void onCreate() {&#10;        super.onCreate();&#10;&#10;        IntentFilter filter = new IntentFilter(ACTION_CMD_FINISHED);&#10;        if (Build.VERSION.SDK_INT &gt;= 33) {&#10;            registerReceiver(cmdFinishedReceiver, filter, Context.RECEIVER_NOT_EXPORTED);&#10;        } else {&#10;            registerReceiver(cmdFinishedReceiver, filter);&#10;        }&#10;&#10;        IntentFilter fFall = new IntentFilter(FallSignals.ACTION_FALL_DETECTED);&#10;        if (Build.VERSION.SDK_INT &gt;= 33) {&#10;            registerReceiver(fallReceiver, fFall, Context.RECEIVER_NOT_EXPORTED);&#10;        } else {&#10;            registerReceiver(fallReceiver, fFall);&#10;        }&#10;&#10;        createChannel();&#10;        updateForegroundNotification(&quot;Escuchando \&quot;Toto\&quot;&quot;);&#10;&#10;        LibVosk.setLogLevel(LogLevel.WARNINGS);&#10;        initTTS();&#10;&#10;        StorageService.unpack(&#10;                this,&#10;                &quot;model-es&quot;,&#10;                &quot;model&quot;,&#10;                new StorageService.Callback&lt;Model&gt;() {&#10;                    @Override public void onComplete(Model m) {&#10;                        model = m;&#10;                        startWakeListening();&#10;                    }&#10;                },&#10;                new StorageService.Callback&lt;IOException&gt;() {&#10;                    @Override public void onComplete(IOException e) {&#10;                        Log.e(TAG, &quot;Error cargando modelo Vosk&quot;, e);&#10;                        Toast.makeText(WakeWordService.this, &quot;Error cargando modelo Vosk&quot;, Toast.LENGTH_LONG).show();&#10;                        stopSelf();&#10;                    }&#10;                }&#10;        );&#10;    }&#10;&#10;    @Override&#10;    public void onTaskRemoved(Intent rootIntent) {&#10;        Intent i = new Intent(getApplicationContext(), WakeWordService.class);&#10;        androidx.core.content.ContextCompat.startForegroundService(getApplicationContext(), i);&#10;        super.onTaskRemoved(rootIntent);&#10;    }&#10;&#10;    private void initTTS() {&#10;        tts = new TextToSpeech(getApplicationContext(), status -&gt; {&#10;            if (status == TextToSpeech.SUCCESS) {&#10;                int r = tts.setLanguage(new Locale(&quot;es&quot;, &quot;AR&quot;));&#10;                ttsReady = (r != TextToSpeech.LANG_MISSING_DATA &amp;&amp; r != TextToSpeech.LANG_NOT_SUPPORTED);&#10;&#10;                tts.setPitch(0.96f);&#10;                tts.setSpeechRate(0.9f);&#10;&#10;                AudioAttributes attrs = new AudioAttributes.Builder()&#10;                        .setUsage(AudioAttributes.USAGE_ASSISTANT)&#10;                        .setContentType(AudioAttributes.CONTENT_TYPE_SPEECH)&#10;                        .build();&#10;                tts.setAudioAttributes(attrs);&#10;&#10;                tts.setOnUtteranceProgressListener(new UtteranceProgressListener() {&#10;                    @Override public void onStart(String utteranceId) {&#10;                        if (utteranceId != null &amp;&amp; (utteranceId.startsWith(&quot;toto_ack_&quot;) || utteranceId.startsWith(&quot;toto_say_&quot;))) {&#10;                            isSpeaking = true;&#10;                            requestTtsAudioFocus();&#10;                        }&#10;                    }&#10;                    @Override public void onDone(String utteranceId) {&#10;                        new android.os.Handler(getMainLooper()).post(() -&gt; {&#10;                            finishAfterTts(/*kind=*/currentUtteranceKind);&#10;                        });&#10;                    }&#10;                    @Override public void onError(String utteranceId) { onDone(utteranceId); }&#10;                });&#10;            } else {&#10;                ttsReady = false;&#10;                Log.w(TAG, &quot;TTS no inicializó correctamente&quot;);&#10;            }&#10;        });&#10;    }&#10;&#10;    private void startWakeListening() {&#10;        try {&#10;            stopListening();&#10;            if (model == null) return;&#10;&#10;            if (listeningPaused) {&#10;                Log.d(TAG, &quot;startWakeListening: en pausa → no inicio reconocimiento&quot;);&#10;                updateForegroundNotification(&quot;Pausa: no estoy escuchando&quot;);&#10;                return;&#10;            }&#10;&#10;            Recognizer rec = new Recognizer(model, 16000.0f);&#10;            rec.setGrammar(&quot;[\&quot;toto\&quot;]&quot;);&#10;            speechService = new SpeechService(rec, 16000.0f);&#10;            speechService.startListening(this);&#10;&#10;            acquireWakeLock();&#10;            Log.d(TAG, &quot;Wake listening iniciado&quot;);&#10;            updateForegroundNotification(&quot;Escuchando \&quot;Toto\&quot;&quot;);&#10;        } catch (Exception e) {&#10;            Log.e(TAG, &quot;startWakeListening error&quot;, e);&#10;            stopSelf();&#10;        }&#10;    }&#10;&#10;    private void stopListening() {&#10;        if (speechService != null) {&#10;            try { speechService.stop(); } catch (Exception ignored) {}&#10;            try { speechService.shutdown(); } catch (Exception ignored) {}&#10;            speechService = null;&#10;        }&#10;        abandonAudioFocus();&#10;        releaseWakeLock();&#10;    }&#10;&#10;    private void requestTtsAudioFocus() {&#10;        AudioManager am = (AudioManager) getSystemService(AUDIO_SERVICE);&#10;        if (am == null) return;&#10;&#10;        if (Build.VERSION.SDK_INT &gt;= Build.VERSION_CODES.O) {&#10;            AudioAttributes attrs = new AudioAttributes.Builder()&#10;                    .setUsage(AudioAttributes.USAGE_ASSISTANT)&#10;                    .setContentType(AudioAttributes.CONTENT_TYPE_SPEECH)&#10;                    .build();&#10;&#10;            audioFocusRequest = new AudioFocusRequest.Builder(AudioManager.AUDIOFOCUS_GAIN_TRANSIENT_MAY_DUCK)&#10;                    .setAudioAttributes(attrs)&#10;                    .setOnAudioFocusChangeListener(fc -&gt; { })&#10;                    .build();&#10;            am.requestAudioFocus(audioFocusRequest);&#10;        } else {&#10;            am.requestAudioFocus(fc -&gt; { },&#10;                    AudioManager.STREAM_MUSIC,&#10;                    AudioManager.AUDIOFOCUS_GAIN_TRANSIENT_MAY_DUCK);&#10;        }&#10;    }&#10;&#10;    private void abandonAudioFocus() {&#10;        AudioManager am = (AudioManager) getSystemService(AUDIO_SERVICE);&#10;        if (am == null) return;&#10;&#10;        if (Build.VERSION.SDK_INT &gt;= Build.VERSION_CODES.O) {&#10;            if (audioFocusRequest != null) am.abandonAudioFocusRequest(audioFocusRequest);&#10;        } else {&#10;            am.abandonAudioFocus(null);&#10;        }&#10;    }&#10;&#10;    private void startInstructionService() {&#10;        stopListening();&#10;        Intent i = new Intent(this, InstructionService.class);&#10;        i.putExtra(&quot;user_name&quot;, userName);&#10;        startService(i); // Servicio normal, NO FGS&#10;    }&#10;&#10;    @Override&#10;    public int onStartCommand(Intent intent, int flags, int startId) {&#10;        if (intent != null) {&#10;            String action = intent.getAction();&#10;&#10;            if (ACTION_SAY.equals(action)) {&#10;                String toSay = intent.getStringExtra(&quot;text&quot;);&#10;                boolean chain = intent.getBooleanExtra(EXTRA_AFTER_SAY_START_SERVICE, false);&#10;                if (chain) {&#10;                    Intent next = new Intent(this, InstructionService.class);&#10;                    String un = intent.getStringExtra(EXTRA_AFTER_SAY_USER_NAME);&#10;                    if (un != null) next.putExtra(&quot;user_name&quot;, un);&#10;                    String fm = intent.getStringExtra(EXTRA_AFTER_SAY_FALL_MODE);&#10;                    if (fm != null) next.putExtra(&quot;fall_mode&quot;, fm);&#10;                    pendingAfterSay = next;&#10;                } else {&#10;                    pendingAfterSay = null;&#10;                }&#10;&#10;                if (toSay != null &amp;&amp; !toSay.trim().isEmpty()) {&#10;                    speakText(toSay.trim());&#10;                }&#10;                return START_NOT_STICKY;&#10;            }&#10;&#10;            if (ACTION_PAUSE_LISTEN.equals(action)) {&#10;                pauseListening();&#10;                return START_STICKY;&#10;            }&#10;            if (ACTION_RESUME_LISTEN.equals(action)) {&#10;               String reason = intent.getStringExtra(EXTRA_REASON);&#10;                if (REASON_FALL_CLEAR.equals(reason)) {&#10;                    blockWakeUntilMs = SystemClock.elapsedRealtime() + 3000;&#10;                    Log.d(TAG, &quot;Resume after FALL_CLEAR → block wake until &quot; + blockWakeUntilMs);&#10;                }&#10;                resumeListening();&#10;                return START_STICKY;&#10;            }&#10;&#10;            if (ACTION_STOP_TTS.equals(action)) {&#10;                stopSpeaking();&#10;                return START_STICKY;&#10;            }&#10;&#10;            if (ACTION_CMD_FINISHED.equals(action)) {&#10;                Log.d(TAG, &quot;ACTION_CMD_FINISHED (startService) → rearmar wake&quot;);&#10;                rearmWake();&#10;                return START_STICKY;&#10;            }&#10;&#10;            if (intent.hasExtra(&quot;user_name&quot;)) {&#10;                String incoming = intent.getStringExtra(&quot;user_name&quot;);&#10;                if (incoming != null &amp;&amp; !incoming.trim().isEmpty()) {&#10;                    userName = incoming.trim();&#10;                }&#10;            }&#10;        }&#10;        return START_STICKY;&#10;    }&#10;&#10;    private void rearmWake() {&#10;        triggered = false;&#10;        lastDetectionText = &quot;&quot;;&#10;        lastDetectionAt = 0L;&#10;        if (listeningPaused) {&#10;            Log.d(TAG, &quot;Wake en pausa → no rearmo escucha&quot;);&#10;            updateForegroundNotification(&quot;Pausa: no estoy escuchando&quot;);&#10;            return;&#10;        }&#10;        new android.os.Handler(getMainLooper()).post(this::startWakeListening);&#10;    }&#10;&#10;    @Override&#10;    public void onDestroy() {&#10;        super.onDestroy();&#10;        try { unregisterReceiver(cmdFinishedReceiver); } catch (Exception ignored) {}&#10;        try { unregisterReceiver(fallReceiver); } catch (Exception ignored) {}&#10;        stopListening();&#10;        if (model != null) { model.close(); model = null; }&#10;        if (tts != null) { try { tts.stop(); } catch (Exception ignored) {} tts.shutdown(); tts = null; }&#10;        releaseWakeLock();&#10;        abandonAudioFocus();&#10;    }&#10;&#10;    @Nullable @Override public IBinder onBind(Intent intent) { return null; }&#10;&#10;    // === RecognitionListener ===&#10;    @Override public void onPartialResult(String hypothesis) { checkForWakeWord(hypothesis); }&#10;    @Override public void onResult(String hypothesis) { checkForWakeWord(hypothesis); }&#10;    @Override public void onFinalResult(String hypothesis) { /* no-op extra */ }&#10;    @Override public void onError(Exception e) { Log.e(TAG, &quot;ASR error&quot;, e); }&#10;    @Override public void onTimeout() { }&#10;&#10;    private static final Pattern WAKE_PATTERN = Pattern.compile(&quot;\\btoto\\b&quot;);&#10;&#10;    private void checkForWakeWord(String json) {&#10;        try {&#10;            long now = SystemClock.elapsedRealtime();&#10;            if (now &lt; blockWakeUntilMs) {&#10;                return;&#10;            }&#10;&#10;            if (FallSignals.isActive()) {&#10;                return;&#10;            }&#10;&#10;            JSONObject jo = new JSONObject(json);&#10;            String recognized = jo.optString(&quot;text&quot;, &quot;&quot;);&#10;            if (recognized == null || recognized.trim().isEmpty()) {&#10;                recognized = jo.optString(&quot;partial&quot;, &quot;&quot;);&#10;            }&#10;            if (recognized == null) recognized = &quot;&quot;;&#10;            recognized = recognized.toLowerCase(Locale.ROOT).trim();&#10;            if (recognized.isEmpty()) return;&#10;&#10;            if (recognized.equals(lastDetectionText) &amp;&amp; (now - lastDetectionAt) &lt; DEDUPE_WINDOW_MS) {&#10;                Log.d(TAG, &quot;Detección duplicada ignorada: &quot; + recognized);&#10;                return;&#10;            }&#10;&#10;            if (WAKE_PATTERN.matcher(recognized).find()) {&#10;                lastDetectionText = recognized;&#10;                lastDetectionAt = now;&#10;&#10;                boolean cooling = (now - lastTriggerAt) &lt; MIN_COOLDOWN_MS;&#10;                if (!triggered &amp;&amp; !cooling) {&#10;                    triggered = true;&#10;                    lastTriggerAt = now;&#10;                    onWakeWordDetected();&#10;                } else {&#10;                    Log.d(TAG, &quot;Ignorado (cooldown o ya triggered)&quot;);&#10;                }&#10;            }&#10;        } catch (Exception ignored) { }&#10;    }&#10;&#10;    private void onWakeWordDetected() {&#10;        Log.d(TAG, &quot;WAKE WORD DETECTED: TOTO&quot;);&#10;        Toast.makeText(this, &quot;¡Hola! Te escucho…&quot;, Toast.LENGTH_SHORT).show();&#10;&#10;        if (FallSignals.isActive()) {&#10;            Log.d(TAG, &quot;WakeWord: caída activa → ignorar ACK/conversación&quot;);&#10;            return;&#10;        }&#10;&#10;        if (ttsReady &amp;&amp; tts != null) {&#10;            String template = ACK_TEMPLATES[rng.nextInt(ACK_TEMPLATES.length)];&#10;            String text = String.format(Locale.getDefault(), template, userName);&#10;            String s = TtsSanitizer.sanitizeForTTS(text);&#10;&#10;            Bundle params = new Bundle();&#10;            String utteranceId = &quot;toto_ack_&quot; + System.currentTimeMillis();&#10;            stopListening();&#10;            isSpeaking = true;&#10;            currentUtteranceKind = &quot;ACK&quot;;&#10;            tts.speak(s, TextToSpeech.QUEUE_FLUSH, params, utteranceId);&#10;        } else {&#10;            startInstructionService();&#10;        }&#10;    }&#10;&#10;    private void createChannel() {&#10;        if (Build.VERSION.SDK_INT &gt;= Build.VERSION_CODES.O) {&#10;            NotificationChannel ch = new NotificationChannel(&#10;                    CHANNEL_ID,&#10;                    &quot;Toto Listening&quot;,&#10;                    NotificationManager.IMPORTANCE_LOW&#10;            );&#10;            ch.setDescription(&quot;Servicio de escucha de la palabra Toto&quot;);&#10;            NotificationManager nm = getSystemService(NotificationManager.class);&#10;            if (nm != null) nm.createNotificationChannel(ch);&#10;        }&#10;    }&#10;&#10;    private void updateForegroundNotification(String contentText) {&#10;        Notification notif = new NotificationCompat.Builder(this, CHANNEL_ID)&#10;                .setContentTitle(&quot;Toto&quot;)&#10;                .setContentText(contentText)&#10;                .setSmallIcon(android.R.drawable.ic_btn_speak_now)&#10;                .setOngoing(true)&#10;                .build();&#10;        startForeground(1001, notif);&#10;    }&#10;&#10;    private void speakText(String text) {&#10;        stopListening();&#10;        if (ttsReady &amp;&amp; tts != null) {&#10;            String s = TtsSanitizer.sanitizeForTTS(text);&#10;            Bundle params = new Bundle();&#10;            String utteranceId = &quot;toto_say_&quot; + System.currentTimeMillis();&#10;            isSpeaking = true;&#10;            currentUtteranceKind = &quot;SAY&quot;;&#10;            tts.speak(s, TextToSpeech.QUEUE_FLUSH, params, utteranceId);&#10;        } else {&#10;            Log.w(TAG, &quot;TTS no listo para hablar&quot;);&#10;        }&#10;    }&#10;&#10;    private void stopSpeaking() {&#10;        if (tts == null || !isSpeaking) {&#10;            Log.d(TAG, &quot;stopSpeaking: no hay TTS en curso&quot;);&#10;            return;&#10;        }&#10;        try { tts.stop(); } catch (Exception ignored) {}&#10;        finishAfterTts(/*kind=*/currentUtteranceKind);&#10;    }&#10;&#10;    /** Unifica el flujo de finalización de TTS para onDone() y stopSpeaking(). */&#10;    private void finishAfterTts(@Nullable String kindSnapshot) {&#10;        // reset estado TTS&#10;        currentUtteranceKind = null;&#10;        isSpeaking = false;&#10;        abandonAudioFocus();&#10;&#10;        if (&quot;ACK&quot;.equals(kindSnapshot)) {&#10;            if (!FallSignals.isActive()) {&#10;                startInstructionService();&#10;            }&#10;            return;&#10;        }&#10;        if (pendingAfterSay != null) {&#10;            try { startService(pendingAfterSay); } catch (Exception ignored) {}&#10;            pendingAfterSay = null;&#10;            return;&#10;        }&#10;        triggered = false;&#10;        lastDetectionText = &quot;&quot;;&#10;        lastDetectionAt = 0L;&#10;        if (!listeningPaused) {&#10;            startWakeListening();&#10;        } else {&#10;            Log.d(TAG, &quot;Fin TTS: en pausa → no rearmo&quot;);&#10;            updateForegroundNotification(&quot;Pausa: no estoy escuchando&quot;);&#10;        }&#10;    }&#10;&#10;    private void pauseListening() {&#10;        listeningPaused = true;&#10;        stopListening();&#10;        updateForegroundNotification(&quot;Pausa: no estoy escuchando&quot;);&#10;        Log.d(TAG, &quot;Wake pausado por acción de usuario&quot;);&#10;    }&#10;&#10;    private void resumeListening() {&#10;        listeningPaused = false;&#10;        Log.d(TAG, &quot;Wake reanudado por acción de usuario&quot;);&#10;        startWakeListening();&#10;    }&#10;}&#10;" />
              <option name="updatedContent" value="package com.example.toto_app.services;&#10;&#10;import android.app.Notification;&#10;import android.app.NotificationChannel;&#10;import android.app.NotificationManager;&#10;import android.app.Service;&#10;import android.content.BroadcastReceiver;&#10;import android.content.Context;&#10;import android.content.Intent;&#10;import android.content.IntentFilter;&#10;import android.media.AudioAttributes;&#10;import android.media.AudioFocusRequest;&#10;import android.media.AudioManager;&#10;import android.os.Build;&#10;import android.os.Bundle;&#10;import android.os.IBinder;&#10;import android.os.PowerManager;&#10;import android.os.SystemClock;&#10;import android.speech.tts.TextToSpeech;&#10;import android.speech.tts.UtteranceProgressListener;&#10;import android.util.Log;&#10;import android.widget.Toast;&#10;&#10;import androidx.annotation.Nullable;&#10;import androidx.core.app.NotificationCompat;&#10;&#10;import org.json.JSONObject;&#10;import org.vosk.LibVosk;&#10;import org.vosk.LogLevel;&#10;import org.vosk.Model;&#10;import org.vosk.Recognizer;&#10;import org.vosk.android.RecognitionListener;&#10;import org.vosk.android.SpeechService;&#10;import org.vosk.android.StorageService;&#10;&#10;import java.io.IOException;&#10;import java.util.Locale;&#10;import java.util.Random;&#10;import java.util.regex.Pattern;&#10;&#10;import com.example.toto_app.falls.FallSignals;&#10;import com.example.toto_app.util.TtsSanitizer;&#10;&#10;public class WakeWordService extends Service implements RecognitionListener {&#10;&#10;    public static final String ACTION_CMD_FINISHED  = &quot;com.example.toto_app.ACTION_CMD_FINISHED&quot;;&#10;    public static final String ACTION_SAY           = &quot;com.example.toto_app.ACTION_SAY&quot;;&#10;&#10;    public static final String ACTION_PAUSE_LISTEN  = &quot;com.example.toto_app.ACTION_PAUSE_LISTEN&quot;;&#10;    public static final String ACTION_RESUME_LISTEN = &quot;com.example.toto_app.ACTION_RESUME_LISTEN&quot;;&#10;&#10;    public static final String ACTION_STOP_TTS      = &quot;com.example.toto_app.ACTION_STOP_TTS&quot;;&#10;&#10;    public static final String EXTRA_AFTER_SAY_START_SERVICE = &quot;after_say_start_service&quot;;&#10;    public static final String EXTRA_AFTER_SAY_USER_NAME     = &quot;after_say_user_name&quot;;&#10;    public static final String EXTRA_AFTER_SAY_FALL_MODE     = &quot;after_say_fall_mode&quot;;&#10;&#10;    public static final String EXTRA_REASON         = &quot;reason&quot;;&#10;    public static final String REASON_FALL_CLEAR    = &quot;FALL_CLEAR&quot;;&#10;&#10;    @Nullable private Intent pendingAfterSay;&#10;&#10;    private static final String TAG = &quot;WakeWord&quot;;&#10;    private static final String CHANNEL_ID = &quot;toto_listening&quot;;&#10;&#10;    private static final long MIN_COOLDOWN_MS   = 1500;&#10;    private static final long DEDUPE_WINDOW_MS  = 2500;&#10;&#10;    private long   lastTriggerAt     = 0L;&#10;    private long   lastDetectionAt   = 0L;&#10;    private String lastDetectionText = &quot;&quot;;&#10;    private volatile boolean triggered = false;&#10;&#10;    private String userName = &quot;Juan&quot;;&#10;&#10;    private Model model;&#10;    private SpeechService speechService;&#10;&#10;    private TextToSpeech tts;&#10;    private volatile boolean ttsReady = false;&#10;    private final Random rng = new Random();&#10;&#10;    private volatile boolean isSpeaking = false;&#10;&#10;    private PowerManager.WakeLock wakeLock;&#10;    @Nullable private AudioFocusRequest audioFocusRequest;&#10;&#10;    // Estado de pausa de escucha&#10;    private volatile boolean listeningPaused = false;&#10;&#10;    // “tipo” de lo que se está diciendo ahora (&quot;ACK&quot; o &quot;SAY&quot;)&#10;    @Nullable private String currentUtteranceKind = null;&#10;&#10;    private volatile long blockWakeUntilMs = 0L;&#10;&#10;    private static final String[] ACK_TEMPLATES = new String[] {&#10;            &quot;¿En qué te puedo ayudar, %s?&quot;,&#10;            &quot;Sí, %s, decime.&quot;,&#10;            &quot;Te escucho, %s.&quot;,&#10;            &quot;%s, decime.&quot;,&#10;            &quot;¿Qué necesitás, %s?&quot;,&#10;            &quot;Acá estoy, %s.&quot;&#10;    };&#10;&#10;    private void acquireWakeLock() {&#10;        if (wakeLock == null) {&#10;            PowerManager pm = (PowerManager) getSystemService(POWER_SERVICE);&#10;            if (pm != null) {&#10;                wakeLock = pm.newWakeLock(PowerManager.PARTIAL_WAKE_LOCK, TAG + &quot;:MicLock&quot;);&#10;                wakeLock.setReferenceCounted(false);&#10;            }&#10;        }&#10;        if (wakeLock != null &amp;&amp; !wakeLock.isHeld()) {&#10;            wakeLock.acquire(10 * 60 * 1000L);&#10;        }&#10;    }&#10;&#10;    private void releaseWakeLock() {&#10;        if (wakeLock != null &amp;&amp; wakeLock.isHeld()) {&#10;            try { wakeLock.release(); } catch (Exception ignored) {}&#10;        }&#10;    }&#10;&#10;    private final BroadcastReceiver cmdFinishedReceiver = new BroadcastReceiver() {&#10;        @Override public void onReceive(Context context, Intent intent) {&#10;            Log.d(TAG, &quot;ACTION_CMD_FINISHED (broadcast) → rearmar wake&quot;);&#10;            rearmWake();&#10;        }&#10;    };&#10;&#10;    private final BroadcastReceiver fallReceiver = new BroadcastReceiver() {&#10;        @Override public void onReceive(Context context, Intent intent) {&#10;            String src = intent.getStringExtra(FallSignals.EXTRA_SOURCE);&#10;            String un  = intent.getStringExtra(FallSignals.EXTRA_USER_NAME);&#10;&#10;            if (!FallSignals.tryActivate()) return;&#10;&#10;            Intent stopTts = new Intent(WakeWordService.this, WakeWordService.class).setAction(ACTION_STOP_TTS);&#10;            androidx.core.content.ContextCompat.startForegroundService(WakeWordService.this, stopTts);&#10;&#10;            Intent pause = new Intent(WakeWordService.this, WakeWordService.class).setAction(ACTION_PAUSE_LISTEN);&#10;            androidx.core.content.ContextCompat.startForegroundService(WakeWordService.this, pause);&#10;&#10;            String who = (un == null || un.trim().isEmpty()) ? userName : un.trim();&#10;            Intent say = new Intent(WakeWordService.this, WakeWordService.class)&#10;                    .setAction(ACTION_SAY)&#10;                    .putExtra(&quot;text&quot;, &quot;Escuché un golpe. ¿Estás bien?&quot;)&#10;                    .putExtra(EXTRA_AFTER_SAY_START_SERVICE, true)&#10;                    .putExtra(EXTRA_AFTER_SAY_USER_NAME, who)&#10;                    .putExtra(EXTRA_AFTER_SAY_FALL_MODE, &quot;AWAIT:0&quot;);&#10;            androidx.core.content.ContextCompat.startForegroundService(WakeWordService.this, say);&#10;        }&#10;    };&#10;&#10;    @Override&#10;    public void onCreate() {&#10;        super.onCreate();&#10;&#10;        IntentFilter filter = new IntentFilter(ACTION_CMD_FINISHED);&#10;        if (Build.VERSION.SDK_INT &gt;= 33) {&#10;            registerReceiver(cmdFinishedReceiver, filter, Context.RECEIVER_NOT_EXPORTED);&#10;        } else {&#10;            registerReceiver(cmdFinishedReceiver, filter);&#10;        }&#10;&#10;        IntentFilter fFall = new IntentFilter(FallSignals.ACTION_FALL_DETECTED);&#10;        if (Build.VERSION.SDK_INT &gt;= 33) {&#10;            registerReceiver(fallReceiver, fFall, Context.RECEIVER_NOT_EXPORTED);&#10;        } else {&#10;            registerReceiver(fallReceiver, fFall);&#10;        }&#10;&#10;        createChannel();&#10;        updateForegroundNotification(&quot;Escuchando \&quot;Toto\&quot;&quot;);&#10;&#10;        LibVosk.setLogLevel(LogLevel.WARNINGS);&#10;        initTTS();&#10;&#10;        StorageService.unpack(&#10;                this,&#10;                &quot;model-es&quot;,&#10;                &quot;model&quot;,&#10;                new StorageService.Callback&lt;Model&gt;() {&#10;                    @Override public void onComplete(Model m) {&#10;                        model = m;&#10;                        com.example.toto_app.services.WakeWordServiceModelHolder.setModel(m);&#10;                        startWakeListening();&#10;                    }&#10;                },&#10;                new StorageService.Callback&lt;IOException&gt;() {&#10;                    @Override public void onComplete(IOException e) {&#10;                        Log.e(TAG, &quot;Error cargando modelo Vosk&quot;, e);&#10;                        Toast.makeText(WakeWordService.this, &quot;Error cargando modelo Vosk&quot;, Toast.LENGTH_LONG).show();&#10;                        stopSelf();&#10;                    }&#10;                }&#10;        );&#10;    }&#10;&#10;    @Override&#10;    public void onTaskRemoved(Intent rootIntent) {&#10;        Intent i = new Intent(getApplicationContext(), WakeWordService.class);&#10;        androidx.core.content.ContextCompat.startForegroundService(getApplicationContext(), i);&#10;        super.onTaskRemoved(rootIntent);&#10;    }&#10;&#10;    private void initTTS() {&#10;        tts = new TextToSpeech(getApplicationContext(), status -&gt; {&#10;            if (status == TextToSpeech.SUCCESS) {&#10;                int r = tts.setLanguage(new Locale(&quot;es&quot;, &quot;AR&quot;));&#10;                ttsReady = (r != TextToSpeech.LANG_MISSING_DATA &amp;&amp; r != TextToSpeech.LANG_NOT_SUPPORTED);&#10;&#10;                tts.setPitch(0.96f);&#10;                tts.setSpeechRate(0.9f);&#10;&#10;                AudioAttributes attrs = new AudioAttributes.Builder()&#10;                        .setUsage(AudioAttributes.USAGE_ASSISTANT)&#10;                        .setContentType(AudioAttributes.CONTENT_TYPE_SPEECH)&#10;                        .build();&#10;                tts.setAudioAttributes(attrs);&#10;&#10;                tts.setOnUtteranceProgressListener(new UtteranceProgressListener() {&#10;                    @Override public void onStart(String utteranceId) {&#10;                        if (utteranceId != null &amp;&amp; (utteranceId.startsWith(&quot;toto_ack_&quot;) || utteranceId.startsWith(&quot;toto_say_&quot;))) {&#10;                            isSpeaking = true;&#10;                            requestTtsAudioFocus();&#10;                        }&#10;                    }&#10;                    @Override public void onDone(String utteranceId) {&#10;                        new android.os.Handler(getMainLooper()).post(() -&gt; {&#10;                            finishAfterTts(/*kind=*/currentUtteranceKind);&#10;                        });&#10;                    }&#10;                    @Override public void onError(String utteranceId) { onDone(utteranceId); }&#10;                });&#10;            } else {&#10;                ttsReady = false;&#10;                Log.w(TAG, &quot;TTS no inicializó correctamente&quot;);&#10;            }&#10;        });&#10;    }&#10;&#10;    private void startWakeListening() {&#10;        try {&#10;            stopListening();&#10;            if (model == null) return;&#10;&#10;            if (listeningPaused) {&#10;                Log.d(TAG, &quot;startWakeListening: en pausa → no inicio reconocimiento&quot;);&#10;                updateForegroundNotification(&quot;Pausa: no estoy escuchando&quot;);&#10;                return;&#10;            }&#10;&#10;            Recognizer rec = new Recognizer(model, 16000.0f);&#10;            rec.setGrammar(&quot;[\&quot;toto\&quot;]&quot;);&#10;            speechService = new SpeechService(rec, 16000.0f);&#10;            speechService.startListening(this);&#10;&#10;            acquireWakeLock();&#10;            Log.d(TAG, &quot;Wake listening iniciado&quot;);&#10;            updateForegroundNotification(&quot;Escuchando \&quot;Toto\&quot;&quot;);&#10;        } catch (Exception e) {&#10;            Log.e(TAG, &quot;startWakeListening error&quot;, e);&#10;            stopSelf();&#10;        }&#10;    }&#10;&#10;    private void stopListening() {&#10;        if (speechService != null) {&#10;            try { speechService.stop(); } catch (Exception ignored) {}&#10;            try { speechService.shutdown(); } catch (Exception ignored) {}&#10;            speechService = null;&#10;        }&#10;        abandonAudioFocus();&#10;        releaseWakeLock();&#10;    }&#10;&#10;    private void requestTtsAudioFocus() {&#10;        AudioManager am = (AudioManager) getSystemService(AUDIO_SERVICE);&#10;        if (am == null) return;&#10;&#10;        if (Build.VERSION.SDK_INT &gt;= Build.VERSION_CODES.O) {&#10;            AudioAttributes attrs = new AudioAttributes.Builder()&#10;                    .setUsage(AudioAttributes.USAGE_ASSISTANT)&#10;                    .setContentType(AudioAttributes.CONTENT_TYPE_SPEECH)&#10;                    .build();&#10;&#10;            audioFocusRequest = new AudioFocusRequest.Builder(AudioManager.AUDIOFOCUS_GAIN_TRANSIENT_MAY_DUCK)&#10;                    .setAudioAttributes(attrs)&#10;                    .setOnAudioFocusChangeListener(fc -&gt; { })&#10;                    .build();&#10;            am.requestAudioFocus(audioFocusRequest);&#10;        } else {&#10;            am.requestAudioFocus(fc -&gt; { },&#10;                    AudioManager.STREAM_MUSIC,&#10;                    AudioManager.AUDIOFOCUS_GAIN_TRANSIENT_MAY_DUCK);&#10;        }&#10;    }&#10;&#10;    private void abandonAudioFocus() {&#10;        AudioManager am = (AudioManager) getSystemService(AUDIO_SERVICE);&#10;        if (am == null) return;&#10;&#10;        if (Build.VERSION.SDK_INT &gt;= Build.VERSION_CODES.O) {&#10;            if (audioFocusRequest != null) am.abandonAudioFocusRequest(audioFocusRequest);&#10;        } else {&#10;            am.abandonAudioFocus(null);&#10;        }&#10;    }&#10;&#10;    private void startInstructionService() {&#10;        stopListening();&#10;        Intent i = new Intent(this, InstructionService.class);&#10;        i.putExtra(&quot;user_name&quot;, userName);&#10;        startService(i); // Servicio normal, NO FGS&#10;    }&#10;&#10;    @Override&#10;    public int onStartCommand(Intent intent, int flags, int startId) {&#10;        if (intent != null) {&#10;            String action = intent.getAction();&#10;&#10;            if (ACTION_SAY.equals(action)) {&#10;                String toSay = intent.getStringExtra(&quot;text&quot;);&#10;                boolean chain = intent.getBooleanExtra(EXTRA_AFTER_SAY_START_SERVICE, false);&#10;                if (chain) {&#10;                    Intent next = new Intent(this, InstructionService.class);&#10;                    String un = intent.getStringExtra(EXTRA_AFTER_SAY_USER_NAME);&#10;                    if (un != null) next.putExtra(&quot;user_name&quot;, un);&#10;                    String fm = intent.getStringExtra(EXTRA_AFTER_SAY_FALL_MODE);&#10;                    if (fm != null) next.putExtra(&quot;fall_mode&quot;, fm);&#10;                    pendingAfterSay = next;&#10;                } else {&#10;                    pendingAfterSay = null;&#10;                }&#10;&#10;                if (toSay != null &amp;&amp; !toSay.trim().isEmpty()) {&#10;                    speakText(toSay.trim());&#10;                }&#10;                return START_NOT_STICKY;&#10;            }&#10;&#10;            if (ACTION_PAUSE_LISTEN.equals(action)) {&#10;                pauseListening();&#10;                return START_STICKY;&#10;            }&#10;            if (ACTION_RESUME_LISTEN.equals(action)) {&#10;               String reason = intent.getStringExtra(EXTRA_REASON);&#10;                if (REASON_FALL_CLEAR.equals(reason)) {&#10;                    blockWakeUntilMs = SystemClock.elapsedRealtime() + 3000;&#10;                    Log.d(TAG, &quot;Resume after FALL_CLEAR → block wake until &quot; + blockWakeUntilMs);&#10;                }&#10;                resumeListening();&#10;                return START_STICKY;&#10;            }&#10;&#10;            if (ACTION_STOP_TTS.equals(action)) {&#10;                stopSpeaking();&#10;                return START_STICKY;&#10;            }&#10;&#10;            if (ACTION_CMD_FINISHED.equals(action)) {&#10;                Log.d(TAG, &quot;ACTION_CMD_FINISHED (startService) → rearmar wake&quot;);&#10;                rearmWake();&#10;                return START_STICKY;&#10;            }&#10;&#10;            if (intent.hasExtra(&quot;user_name&quot;)) {&#10;                String incoming = intent.getStringExtra(&quot;user_name&quot;);&#10;                if (incoming != null &amp;&amp; !incoming.trim().isEmpty()) {&#10;                    userName = incoming.trim();&#10;                }&#10;            }&#10;        }&#10;        return START_STICKY;&#10;    }&#10;&#10;    private void rearmWake() {&#10;        triggered = false;&#10;        lastDetectionText = &quot;&quot;;&#10;        lastDetectionAt = 0L;&#10;        if (listeningPaused) {&#10;            Log.d(TAG, &quot;Wake en pausa → no rearmo escucha&quot;);&#10;            updateForegroundNotification(&quot;Pausa: no estoy escuchando&quot;);&#10;            return;&#10;        }&#10;        new android.os.Handler(getMainLooper()).post(this::startWakeListening);&#10;    }&#10;&#10;    @Override&#10;    public void onDestroy() {&#10;        super.onDestroy();&#10;        try { unregisterReceiver(cmdFinishedReceiver); } catch (Exception ignored) {}&#10;        try { unregisterReceiver(fallReceiver); } catch (Exception ignored) {}&#10;        stopListening();&#10;        if (model != null) { model.close(); model = null; }&#10;        if (tts != null) { try { tts.stop(); } catch (Exception ignored) {} tts.shutdown(); tts = null; }&#10;        releaseWakeLock();&#10;        abandonAudioFocus();&#10;    }&#10;&#10;    @Nullable @Override public IBinder onBind(Intent intent) { return null; }&#10;&#10;    // === RecognitionListener ===&#10;    @Override public void onPartialResult(String hypothesis) { checkForWakeWord(hypothesis); }&#10;    @Override public void onResult(String hypothesis) { checkForWakeWord(hypothesis); }&#10;    @Override public void onFinalResult(String hypothesis) { /* no-op extra */ }&#10;    @Override public void onError(Exception e) { Log.e(TAG, &quot;ASR error&quot;, e); }&#10;    @Override public void onTimeout() { }&#10;&#10;    private static final Pattern WAKE_PATTERN = Pattern.compile(&quot;\\btoto\\b&quot;);&#10;&#10;    private void checkForWakeWord(String json) {&#10;        try {&#10;            long now = SystemClock.elapsedRealtime();&#10;            if (now &lt; blockWakeUntilMs) {&#10;                return;&#10;            }&#10;&#10;            if (FallSignals.isActive()) {&#10;                return;&#10;            }&#10;&#10;            JSONObject jo = new JSONObject(json);&#10;            String recognized = jo.optString(&quot;text&quot;, &quot;&quot;);&#10;            if (recognized == null || recognized.trim().isEmpty()) {&#10;                recognized = jo.optString(&quot;partial&quot;, &quot;&quot;);&#10;            }&#10;            if (recognized == null) recognized = &quot;&quot;;&#10;            recognized = recognized.toLowerCase(Locale.ROOT).trim();&#10;            if (recognized.isEmpty()) return;&#10;&#10;            if (recognized.equals(lastDetectionText) &amp;&amp; (now - lastDetectionAt) &lt; DEDUPE_WINDOW_MS) {&#10;                Log.d(TAG, &quot;Detección duplicada ignorada: &quot; + recognized);&#10;                return;&#10;            }&#10;&#10;            if (WAKE_PATTERN.matcher(recognized).find()) {&#10;                lastDetectionText = recognized;&#10;                lastDetectionAt = now;&#10;&#10;                boolean cooling = (now - lastTriggerAt) &lt; MIN_COOLDOWN_MS;&#10;                if (!triggered &amp;&amp; !cooling) {&#10;                    triggered = true;&#10;                    lastTriggerAt = now;&#10;                    onWakeWordDetected();&#10;                } else {&#10;                    Log.d(TAG, &quot;Ignorado (cooldown o ya triggered)&quot;);&#10;                }&#10;            }&#10;        } catch (Exception ignored) { }&#10;    }&#10;&#10;    private void onWakeWordDetected() {&#10;        Log.d(TAG, &quot;WAKE WORD DETECTED: TOTO&quot;);&#10;        Toast.makeText(this, &quot;¡Hola! Te escucho…&quot;, Toast.LENGTH_SHORT).show();&#10;&#10;        if (FallSignals.isActive()) {&#10;            Log.d(TAG, &quot;WakeWord: caída activa → ignorar ACK/conversación&quot;);&#10;            return;&#10;        }&#10;&#10;        if (ttsReady &amp;&amp; tts != null) {&#10;            String template = ACK_TEMPLATES[rng.nextInt(ACK_TEMPLATES.length)];&#10;            String text = String.format(Locale.getDefault(), template, userName);&#10;            String s = TtsSanitizer.sanitizeForTTS(text);&#10;&#10;            Bundle params = new Bundle();&#10;            String utteranceId = &quot;toto_ack_&quot; + System.currentTimeMillis();&#10;            stopListening();&#10;            isSpeaking = true;&#10;            currentUtteranceKind = &quot;ACK&quot;;&#10;            tts.speak(s, TextToSpeech.QUEUE_FLUSH, params, utteranceId);&#10;        } else {&#10;            startInstructionService();&#10;        }&#10;    }&#10;&#10;    private void createChannel() {&#10;        if (Build.VERSION.SDK_INT &gt;= Build.VERSION_CODES.O) {&#10;            NotificationChannel ch = new NotificationChannel(&#10;                    CHANNEL_ID,&#10;                    &quot;Toto Listening&quot;,&#10;                    NotificationManager.IMPORTANCE_LOW&#10;            );&#10;            ch.setDescription(&quot;Servicio de escucha de la palabra Toto&quot;);&#10;            NotificationManager nm = getSystemService(NotificationManager.class);&#10;            if (nm != null) nm.createNotificationChannel(ch);&#10;        }&#10;    }&#10;&#10;    private void updateForegroundNotification(String contentText) {&#10;        Notification notif = new NotificationCompat.Builder(this, CHANNEL_ID)&#10;                .setContentTitle(&quot;Toto&quot;)&#10;                .setContentText(contentText)&#10;                .setSmallIcon(android.R.drawable.ic_btn_speak_now)&#10;                .setOngoing(true)&#10;                .build();&#10;        startForeground(1001, notif);&#10;    }&#10;&#10;    private void speakText(String text) {&#10;        stopListening();&#10;        if (ttsReady &amp;&amp; tts != null) {&#10;            String s = TtsSanitizer.sanitizeForTTS(text);&#10;            Bundle params = new Bundle();&#10;            String utteranceId = &quot;toto_say_&quot; + System.currentTimeMillis();&#10;            isSpeaking = true;&#10;            currentUtteranceKind = &quot;SAY&quot;;&#10;            tts.speak(s, TextToSpeech.QUEUE_FLUSH, params, utteranceId);&#10;        } else {&#10;            Log.w(TAG, &quot;TTS no listo para hablar&quot;);&#10;        }&#10;    }&#10;&#10;    private void stopSpeaking() {&#10;        if (tts == null || !isSpeaking) {&#10;            Log.d(TAG, &quot;stopSpeaking: no hay TTS en curso&quot;);&#10;            return;&#10;        }&#10;        try { tts.stop(); } catch (Exception ignored) {}&#10;        finishAfterTts(/*kind=*/currentUtteranceKind);&#10;    }&#10;&#10;    /** Unifica el flujo de finalización de TTS para onDone() y stopSpeaking(). */&#10;    private void finishAfterTts(@Nullable String kindSnapshot) {&#10;        // reset estado TTS&#10;        currentUtteranceKind = null;&#10;        isSpeaking = false;&#10;        abandonAudioFocus();&#10;&#10;        if (&quot;ACK&quot;.equals(kindSnapshot)) {&#10;            if (!FallSignals.isActive()) {&#10;                startInstructionService();&#10;            }&#10;            return;&#10;        }&#10;        if (pendingAfterSay != null) {&#10;            try { startService(pendingAfterSay); } catch (Exception ignored) {}&#10;            pendingAfterSay = null;&#10;            return;&#10;        }&#10;        triggered = false;&#10;        lastDetectionText = &quot;&quot;;&#10;        lastDetectionAt = 0L;&#10;        if (!listeningPaused) {&#10;            startWakeListening();&#10;        } else {&#10;            Log.d(TAG, &quot;Fin TTS: en pausa → no rearmo&quot;);&#10;            updateForegroundNotification(&quot;Pausa: no estoy escuchando&quot;);&#10;        }&#10;    }&#10;&#10;    private void pauseListening() {&#10;        listeningPaused = true;&#10;        stopListening();&#10;        updateForegroundNotification(&quot;Pausa: no estoy escuchando&quot;);&#10;        Log.d(TAG, &quot;Wake pausado por acción de usuario&quot;);&#10;    }&#10;&#10;    private void resumeListening() {&#10;        listeningPaused = false;&#10;        Log.d(TAG, &quot;Wake reanudado por acción de usuario&quot;);&#10;        startWakeListening();&#10;    }&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/app/src/main/java/com/example/toto_app/services/WakeWordServiceModelHolder.java">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/app/src/main/java/com/example/toto_app/services/WakeWordServiceModelHolder.java" />
              <option name="updatedContent" value="package com.example.toto_app.services;&#10;&#10;import org.vosk.Model;&#10;&#10;public final class WakeWordServiceModelHolder {&#10;    private static volatile Model MODEL;&#10;    public static void setModel(Model m) { MODEL = m; }&#10;    public static Model getModel() { return MODEL; }&#10;}&#10;" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/app/src/main/java/com/example/toto_app/stt/SttClient.java">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/app/src/main/java/com/example/toto_app/stt/SttClient.java" />
              <option name="originalContent" value="package com.example.toto_app.stt;&#10;&#10;import android.util.Log;&#10;&#10;import com.example.toto_app.network.APIService;&#10;import com.example.toto_app.network.RetrofitClient;&#10;import com.example.toto_app.network.TranscriptionResponse;&#10;&#10;import java.io.File;&#10;&#10;import okhttp3.MediaType;&#10;import okhttp3.MultipartBody;&#10;import okhttp3.RequestBody;&#10;import retrofit2.Call;&#10;import retrofit2.Response;&#10;&#10;public final class SttClient {&#10;    private SttClient(){}&#10;&#10;    public static String transcribe(File wav) {&#10;        String transcript = &quot;&quot;;&#10;        try {&#10;            APIService api = RetrofitClient.api();&#10;            RequestBody fileBody = RequestBody.create(wav, MediaType.parse(&quot;audio/wav&quot;));&#10;            MultipartBody.Part audioPart = MultipartBody.Part.createFormData(&quot;audio&quot;, wav.getName(), fileBody);&#10;            Call&lt;TranscriptionResponse&gt; call = api.transcribe(audioPart, null, null);&#10;            Response&lt;TranscriptionResponse&gt; resp = call.execute();&#10;&#10;            if (resp.isSuccessful() &amp;&amp; resp.body() != null) {&#10;                transcript = resp.body().text != null ? resp.body().text.trim() : &quot;&quot;;&#10;                Log.d(&quot;SttClient&quot;, &quot;INSTRUCCIÓN (backend STT): &quot; + transcript);&#10;            } else {&#10;                Log.e(&quot;SttClient&quot;, &quot;Transcribe error HTTP: &quot; + (resp != null ? resp.code(): -1));&#10;            }&#10;        } catch (Exception e) {&#10;            Log.e(&quot;SttClient&quot;, &quot;Error llamando backend STT&quot;, e);&#10;        }&#10;        return transcript;&#10;    }&#10;}&#10;&#10;&#10;&#10;" />
              <option name="updatedContent" value="package com.example.toto_app.stt;&#10;&#10;import android.util.Log;&#10;&#10;import com.example.toto_app.network.APIService;&#10;import com.example.toto_app.network.RetrofitClient;&#10;import com.example.toto_app.network.TranscriptionResponse;&#10;&#10;import java.io.File;&#10;&#10;import okhttp3.MediaType;&#10;import okhttp3.MultipartBody;&#10;import okhttp3.RequestBody;&#10;import retrofit2.Call;&#10;import retrofit2.Response;&#10;&#10;public final class SttClient {&#10;    private SttClient(){}&#10;&#10;    public static String transcribe(File wav) {&#10;        String transcript = &quot;&quot;;&#10;        // 1) Chequeo rápido si backend parece UP&#10;        boolean up = true;&#10;        try {&#10;            try { up = com.example.toto_app.services.BackendHealthManager.get().isBackendUp(); }&#10;            catch (Throwable ignore) { up = true; }&#10;        } catch (Throwable ignored) { up = true; }&#10;&#10;        if (up) {&#10;            try {&#10;                APIService api = RetrofitClient.api();&#10;                RequestBody fileBody = RequestBody.create(wav, MediaType.parse(&quot;audio/wav&quot;));&#10;                MultipartBody.Part audioPart = MultipartBody.Part.createFormData(&quot;audio&quot;, wav.getName(), fileBody);&#10;                Call&lt;TranscriptionResponse&gt; call = api.transcribe(audioPart, null, null);&#10;                Response&lt;TranscriptionResponse&gt; resp = call.execute();&#10;&#10;                if (resp.isSuccessful() &amp;&amp; resp.body() != null) {&#10;                    transcript = resp.body().text != null ? resp.body().text.trim() : &quot;&quot;;&#10;                    Log.d(&quot;SttClient&quot;, &quot;INSTRUCCIÓN (backend STT): &quot; + transcript);&#10;                    return transcript == null ? &quot;&quot; : transcript;&#10;                } else {&#10;                    Log.w(&quot;SttClient&quot;, &quot;Transcribe error HTTP: &quot; + (resp != null ? resp.code(): -1));&#10;                    try { com.example.toto_app.services.BackendHealthManager.get().markFailure(); } catch (Exception ignore) {}&#10;                }&#10;            } catch (Exception e) {&#10;                Log.w(&quot;SttClient&quot;, &quot;Error llamando backend STT&quot;, e);&#10;                try { com.example.toto_app.services.BackendHealthManager.get().markFailure(); } catch (Exception ignore) {}&#10;            }&#10;        }&#10;&#10;        // 2) Fallback a VOSK local si el modelo está disponible&#10;        try {&#10;            org.vosk.Model model = com.example.toto_app.services.WakeWordServiceModelHolder.getModel();&#10;            if (model != null) {&#10;                org.vosk.Recognizer rec = new org.vosk.Recognizer(model, 16000.0f);&#10;                java.io.FileInputStream fis = null;&#10;                try {&#10;                    fis = new java.io.FileInputStream(wav);&#10;                    long skip = fis.skip(44); // skip WAV header&#10;                    int avail = (int) Math.max(0, wav.length() - 44);&#10;                    byte[] raw = new byte[avail];&#10;                    int offset = 0; int read;&#10;                    while (offset &lt; avail &amp;&amp; (read = fis.read(raw, offset, avail - offset)) &gt; 0) offset += read;&#10;                    if (offset &gt; 0) rec.acceptWaveForm(raw, offset);&#10;                    String res = rec.getFinalResult();&#10;                    if (res != null) {&#10;                        try {&#10;                            org.json.JSONObject jo = new org.json.JSONObject(res);&#10;                            transcript = jo.optString(&quot;text&quot;, &quot;&quot;);&#10;                        } catch (Exception jex) {&#10;                            transcript = res;&#10;                        }&#10;                        Log.d(&quot;SttClient&quot;, &quot;INSTRUCCIÓN (vosk local): &quot; + transcript);&#10;                        return transcript == null ? &quot;&quot; : transcript;&#10;                    }&#10;                } finally { if (fis != null) try { fis.close(); } catch (Exception ignore) {} }&#10;            }&#10;        } catch (Exception e) {&#10;            Log.e(&quot;SttClient&quot;, &quot;Vosk local STT failed&quot;, e);&#10;        }&#10;&#10;        return transcript == null ? &quot;&quot; : transcript;&#10;     }&#10; }" />
            </PendingDiffInfo>
          </value>
        </entry>
      </map>
    </option>
  </component>
</project>